package main

import (
	"bytes"
	_ "embed"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/constant"
	"go/token"
	"go/types"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/gunk/gunk/loader"
	"github.com/kenshaw/inflector"
	"golang.org/x/tools/imports"
)

// signature is prepended to the template and used by gen.go to determine if a
// file has been modified by a human. The first line has been formatted to
// avoid automated tools from modifying the file.
const signature = `// Code generated by gen.go. DO NOT EDIT.
// To avoid your changes from being overwritten, delete this header.

`

var (
	verbose bool
	debug   bool
)

func main() {
	out := flag.String("o", ".", "output directory root")
	flag.BoolVar(&verbose, "v", false, "print debugging information")
	flag.BoolVar(&debug, "d", false, "enable debugging by skipping Go formatting")
	flag.Parse()
	if err := run(*out, flag.Args()...); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

// run executes the main command, generating to the specified output directory.
func run(out string, args ...string) error {
	// Load Gunk files.
	loader := loader.Loader{
		Fset:  token.NewFileSet(),
		Types: true,
	}
	pkgs, err := loader.Load(args...)
	if err != nil {
		return fmt.Errorf("could not load gunk files: %w", err)
	}
	// For each file, locate all methods and generate files for them.
	var encounteredError bool
	for _, pkg := range pkgs {
		verbosef("+ %s\n", pkg.PkgPath)
		if len(pkg.Errors) > 0 {
			encounteredError = true
			fmt.Fprintf(
				os.Stderr, "error loading package %q: %v\n",
				pkg.PkgPath, pkgErrorToMultiError(pkg.Errors),
			)
			continue
		}
		serviceNames := []string{}
		serverNames := []string{}
		skipPrefix := false
		for _, f := range pkg.GunkSyntax {
			for _, tag := range pkg.GunkTags[f] {
				if tag.Type.String() == "github.com/gunk/opt/xo.SkipPrefix" {
					skipPrefix = constant.BoolVal(tag.Value)
				}
			}
		}
		for _, f := range pkg.GunkSyntax {
			var serviceName string
			ast.Inspect(f, func(n ast.Node) bool {
				switch v := n.(type) {
				default:
					return false
				case *ast.GenDecl, *ast.File, *ast.InterfaceType, *ast.FieldList:
					return true
				case *ast.TypeSpec:
					// Only inspect into interfaces.
					_, ok := v.Type.(*ast.InterfaceType)
					if ok {
						serviceName = v.Name.Name
						serviceNames = append(serviceNames, serviceName)
						serverNames = append(serverNames, serverName(pkg.Name, serviceName))
					}
					return ok
				case *ast.Field:
					data := processField(pkg, v, serviceName, skipPrefix)
					// Generate file.
					verbosef("++ %s\n", data.MethodName)
					err := generateField(out, data)
					if err != nil {
						fmt.Fprintf(
							os.Stderr, "error generating method %q in %q: %v\n",
							v.Names[0].Name, pkg.Name, err,
						)
						encounteredError = true
						return false
					}
					return false
				}
			})
		}
		if len(serviceNames) > 0 {
			err := generateServer(out, ServiceData{
				PackageName:  pkg.Name,
				GunkPath:     pkg.PkgPath,
				ServiceNames: serviceNames,
				ServerNames:  serverNames,
			})
			if err != nil {
				fmt.Fprintf(
					os.Stderr, "error generating servers for package %q: %v\n",
					pkg.Name, err,
				)
				encounteredError = true
			}
		}
	}
	if encounteredError {
		return errors.New("encountered error generating methods")
	}
	return nil
}

// shouldOverride returns if the file at the specified path should be
// overwritten (if it is empty or has the signature).
func shouldOverride(path string) (bool, error) {
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		return true, nil
	}
	// If file exists then check if it's hand-written and skip if it is.
	targetFile, err := os.Open(path)
	if err != nil {
		return false, fmt.Errorf("error opening file %q: %w", path, err)
	}
	defer targetFile.Close()
	firstBytes := make([]byte, len(signature))
	_, err = io.ReadFull(targetFile, firstBytes)
	if errors.Is(err, io.ErrUnexpectedEOF) {
		verbosef(
			"skipping file %q: length of file shorter than signature\n", path,
		)
		return false, nil
	}
	if err != nil {
		return false, fmt.Errorf("error reading file %q: %w", path, err)
	}
	if string(firstBytes) != signature {
		// Signature does not match. Skip.
		verbosef(
			"skipping file %q: got %q instead of %q as first bytes\n",
			path, firstBytes, signature,
		)
		return false, nil
	}
	return true, nil
}

// ServiceData is the struct containing data exposed to the service template.
type ServiceData struct {
	PackageName  string
	GunkPath     string
	ServiceNames []string
	ServerNames  []string
}

// generateServer generates a file for the service specified in a subdirectory
// of `out`.
func generateServer(out string, data ServiceData) error {
	folder := filepath.Join(out, data.PackageName)
	if err := os.MkdirAll(folder, 0o755); err != nil {
		return err
	}
	path := filepath.Join(folder, data.PackageName+".go")
	override, err := shouldOverride(path)
	if err != nil {
		return err
	}
	if !override {
		return nil
	}
	buf := new(bytes.Buffer)
	if err := serviceTpl.Execute(buf, data); err != nil {
		return err
	}
	src := buf.Bytes()
	if !debug {
		var err error
		src, err = imports.Process(path, buf.Bytes(), nil)
		if err != nil {
			return err
		}
	}
	return ioutil.WriteFile(path, src, 0o644)
}

// Import is a struct containing an import that needs to be done.
type Import struct {
	Name string
	Path string
}

// MethodData is the struct containing data exposed to the method template.
type MethodData struct {
	PackageName    string
	GunkPath       string
	ModelName      string
	PluralName     string
	ServerName     string
	PermissionName string

	// Extra imports necessary due to Request or Response types.
	Imports []Import

	MethodName   string
	RequestPkg   string
	RequestType  string
	ResponsePkg  string
	ResponseType string

	reqType  *types.Struct
	respType *types.Struct
}

func processField(pkg *loader.GunkPackage, field *ast.Field, serviceName string, skipPrefix bool) MethodData {
	pkgName := pkg.Name
	methodName := field.Names[0].Name
	typ, ok := pkg.TypesInfo.TypeOf(field.Type).(*types.Signature)
	if !ok {
		panic("expected interface fields to be methods")
	}
	singular, plural := modelName(skipPrefix, pkgName, methodName)
	data := MethodData{
		PackageName: pkgName,
		GunkPath:    pkg.PkgPath,
		MethodName:  methodName,
		ModelName:   singular,
		PluralName:  plural,
		ServerName:  serverName(pkgName, serviceName),
		Imports:     make([]Import, 0),
	}
	// Figure out parameters and responses.
	paramPkg, param, paramTyp, ok := firstTupleType(methodName, typ.Params())
	if ok {
		data.RequestType = param
		data.reqType = paramTyp
		if paramPkg.Path() != pkg.PkgPath {
			data.RequestPkg = paramPkg.Name()
			data.Imports = append(data.Imports, Import{
				Name: paramPkg.Name(),
				Path: paramPkg.Path(),
			})
		}
	}
	respPkg, resp, respTyp, ok := firstTupleType(methodName, typ.Results())
	if ok {
		data.ResponseType = resp
		data.respType = respTyp
		if respPkg.Path() != pkg.PkgPath {
			data.ResponsePkg = respPkg.Name()
			data.Imports = append(data.Imports, Import{
				Name: respPkg.Name(),
				Path: respPkg.Path(),
			})
		}
	}
permGenLoop:
	for _, v := range pkg.GunkTags[field] {
		if v.Type.String() == "github.com/gunk/opt/http.Match" {
			for _, elt := range v.Expr.(*ast.CompositeLit).Elts {
				kv := elt.(*ast.KeyValueExpr)
				k := kv.Key.(*ast.Ident).Name
				if k != "Path" {
					continue
				}
				v, _ := strconv.Unquote(kv.Value.(*ast.BasicLit).Value)
				data.PermissionName = pathToPerm(methodName, v)
				break permGenLoop
			}
		}
	}
	return data
}

// generateField generates a file for the method specified in a subdirectory of
// `out`.
func generateField(out string, data MethodData) error {
	folder := filepath.Join(out, data.PackageName)
	if err := os.MkdirAll(folder, 0o755); err != nil {
		return err
	}
	path := filepath.Join(folder, strings.ToLower(data.MethodName)+".go")
	override, err := shouldOverride(path)
	if err != nil {
		return err
	}
	if !override {
		return nil
	}
	buf := new(bytes.Buffer)
	if err := methodTpl.Execute(buf, data); err != nil {
		return err
	}
	src := buf.Bytes()
	if !debug {
		var err error
		src, err = imports.Process(path, buf.Bytes(), nil)
		if err != nil {
			return err
		}
	}
	return ioutil.WriteFile(path, src, 0o644)
}

// firstTupleType returns the name of the first type in the tuple and the package it belongs to.
func firstTupleType(methodName string, t *types.Tuple) (*types.Package, string, *types.Struct, bool) {
	if t.Len() == 0 {
		return nil, "", nil, false
	}
	n, ok := t.At(0).Type().(*types.Named)
	if !ok {
		// Panic with more information.
		// Methods should always have named parameters/return types.
		panic(fmt.Sprintf(
			"unexpected type in %q: got %T instead of an identifier",
			methodName, t.At(0).Type(),
		))
	}
	obj := n.Obj()
	pkg := obj.Pkg()
	param, ok := n.Underlying().(*types.Struct)
	if !ok {
		panic(fmt.Sprintf(
			"unexpected type of %q in %q: got %T instead of a struct",
			obj.Name(), methodName, n.Underlying(),
		))
	}
	return pkg, obj.Name(), param, true
}

// modelName retrieves the name of the model from the method name.
// It can be overwritten by modelOverride.
func modelName(skipPrefix bool, pkgName string, methodName string) (string, string) {
	// Method prefixes.
	methodName = strings.TrimPrefix(methodName, "Create")
	methodName = strings.TrimPrefix(methodName, "Get")
	methodName = strings.TrimPrefix(methodName, "Update")
	methodName = strings.TrimPrefix(methodName, "List")
	methodName = strings.TrimPrefix(methodName, "Delete")
	// Allow overrides.
	if name, ok := modelOverride[pkgName+"."+methodName]; ok {
		return name[0], name[1]
	}
	if name, ok := modelOverride[pkgName+"."+inflector.Singularize(methodName)]; ok {
		return name[0], name[1]
	}

	// Infer name (based on xo/ecosystem).
	methodModel := inflector.Singularize(methodName)
	pkgSingular := inflector.Singularize(string(pkgName))
	pkgTitle := strings.Title(pkgSingular)
	// Prevent pkg_pkg naming.
	if skipPrefix || strings.HasPrefix(methodModel, pkgTitle) {
		return methodModel, inflector.Pluralize(methodModel)
	}
	suffix := strings.TrimPrefix(methodModel, pkgTitle)
	pluralSuffix := inflector.Pluralize(suffix)
	singular := pkgTitle + strings.Title(suffix)
	plural := pkgTitle + strings.Title(pluralSuffix)
	return singular, plural
}

// serverName returns the name of the server based on the package name and the
// service name.
// It can be overwritten with serviceOverride.
func serverName(pkgName string, serviceName string) string {
	if name, ok := serverOverride[pkgName+"."+serviceName]; ok {
		return name
	}
	titledPkg := strings.Title(pkgName)
	singularPkg := strings.Title(inflector.Singularize(pkgName))
	name := strings.ReplaceAll(serviceName, "Service", "Server")
	name = strings.ReplaceAll(name, titledPkg, "")
	name = strings.ReplaceAll(name, singularPkg, "")
	return name
}

// pathToPerm converts a path to the name of the permission assigned to the
// endpoint.
func pathToPerm(methodName string, path string) string {
	p := strings.SplitN(path, ":", 2)
	front := strings.Split(p[0], "/")
	perm := make([]string, 0, len(front)+1)
	for _, v := range front {
		if v == "" || strings.HasPrefix(v, "{") {
			// Skip the first empty entry and path parameters.
			continue
		}
		perm = append(perm, strings.ToLower(v))
	}
	// Infer common verbs if custom verb is not present.
	if len(p) != 1 {
		perm = append(perm, strings.ToLower(p[1]))
	} else {
		switch {
		case strings.HasPrefix(methodName, "Create"):
			perm = append(perm, "create")
		case strings.HasPrefix(methodName, "List"):
			perm = append(perm, "list")
		case strings.HasPrefix(methodName, "Get"):
			perm = append(perm, "get")
		case strings.HasPrefix(methodName, "Update"):
			perm = append(perm, "update")
		case strings.HasPrefix(methodName, "Delete"):
			perm = append(perm, "delete")
		}
	}
	return strings.Join(perm, ".")
}

// toSingular converts the provided plural to singular. It is intentionally
// kept simple and overrides should be used if the heuristics does not work.
func toSingular(plural string) string {
	if strings.HasSuffix(plural, "ies") {
		return plural[:len(plural)-3] + "y"
	}
	if strings.HasSuffix(plural, "es") {
		return plural[:len(plural)-2]
	}
	if strings.HasSuffix(plural, "s") {
		return plural[:len(plural)-1]
	}
	return plural
}

// verbosef prints out the arguments if the verbose flag is set.
func verbosef(formatString string, a ...interface{}) {
	if verbose {
		fmt.Printf(formatString, a...)
	}
}

var (
	methodTpl = template.Must(
		template.New("method.go.tpl").Funcs(extraFuncs).Parse(signature + rawMethodTpl),
	)
	serviceTpl = template.Must(
		template.New("svc.go.tpl").Funcs(extraFuncs).Parse(signature + rawServiceTpl),
	)
)

//go:embed method.go.tpl
var rawMethodTpl string

//go:embed svc.go.tpl
var rawServiceTpl string
