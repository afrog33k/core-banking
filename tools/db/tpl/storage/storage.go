package storage

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/fs"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/kenshaw/inflector"
	"github.com/kenshaw/snaker"
	"github.com/xo/xo/loader"
	xo "github.com/xo/xo/types"
	"golang.org/x/tools/imports"
	"mvdan.cc/gofumpt/format"
)

// Init registers the template.
func Init(_ context.Context, f func(xo.TemplateType)) error {
	f(xo.TemplateType{
		Modes: []string{"schema"},
		Flags: []xo.Flag{
			{
				ContextKey: ProtoKey,
				Type:       "string",
				Desc:       "protobuf names for tables",
			},
			{
				ContextKey: ConflictKey,
				Type:       "string",
				Desc:       "name conflict suffix",
				Default:    "Val",
			},
			{
				ContextKey: InitialismKey,
				Type:       "[]string",
				Desc:       "add initialism (e.g. ID, API, URI, ...)",
			},
		},
		Funcs: func(ctx context.Context, _ string) (template.FuncMap, error) {
			return NewFuncs(ctx)
		},
		Order: func(_ context.Context, mode string) []string {
			base := []string{"header", "db"}
			if mode == "schema" {
				base = append(base, "enum", "interface", "errordef")
			}
			return append(base, "typedef", "query")
		},
		Pre: func(ctx context.Context, mode string, set *xo.Set, _ fs.FS, emit func(xo.Template)) error {
			if err := addInitialisms(ctx); err != nil {
				return err
			}
			proto, err := Proto(ctx)
			if err != nil {
				return err
			}
			files, err := fileNames(ctx, mode, set, proto)
			if err != nil {
				return err
			}
			emit(xo.Template{
				Partial: "db",
				Dest:    "db" + ext,
			})
			emit(xo.Template{
				Partial: "errordef",
				Dest:    "errors" + ext,
			})
			for filename := range files {
				emit(xo.Template{
					Partial: "header",
					Dest:    filename,
				})
			}
			return nil
		},
		Process: func(ctx context.Context, mode string, set *xo.Set, emit func(xo.Template)) error {
			if mode == "query" {
				for _, query := range set.Queries {
					if err := emitQuery(ctx, query, emit); err != nil {
						return err
					}
				}
			} else {
				proto, err := Proto(ctx)
				if err != nil {
					return err
				}
				for _, schema := range set.Schemas {
					if err := emitSchema(ctx, schema, proto, emit); err != nil {
						return err
					}
				}
			}
			return nil
		},
		Post: func(_ context.Context, _ string, files map[string][]byte, emit func(string, []byte)) error {
			for file, content := range files {
				// Run goimports.
				buf, err := imports.Process("", content, nil)
				if err != nil {
					return fmt.Errorf("%s:%w", file, err)
				}
				// Run gofumpt.
				formatted, err := format.Source(buf, format.Options{
					ExtraRules: true,
				})
				if err != nil {
					return err
				}
				emit(file, formatted)
			}
			return nil
		},
	})
	return nil
}

// fileNames returns a list of file names that will be generated by the
// template based on the parameters and schema.
func fileNames(_ context.Context, mode string, set *xo.Set, proto map[string]typeEntry) (map[string]bool, error) {
	// Infer filenames from set.
	files := make(map[string]bool)
	addFiles := func(filenames ...string) {
		// Filenames are always lowercase.
		for _, f := range filenames {
			f = strings.ToLower(f)
			files[f+ext] = true
		}
	}
	switch mode {
	case "schema":
		addFiles("db", "interface", "enums", "errors")
		for _, schema := range set.Schemas {
			for _, t := range schema.Tables {
				if _, ok := proto[t.Name]; !ok {
					continue
				}
				addFiles(camelExport(singularize(t.Name)))
			}
		}
	case "query":
		for _, query := range set.Queries {
			addFiles(query.Type)
			if query.Exec {
				return nil, fmt.Errorf("query exec mode is not supported")
			}
		}
	default:
		panic("unknown mode: " + mode)
	}
	return files, nil
}

// emitQuery emits the query.
func emitQuery(ctx context.Context, query xo.Query, emit func(xo.Template)) error {
	var table Table
	// build type if needed
	if !query.Exec {
		var err error
		if table, err = buildQueryType(ctx, query); err != nil {
			return err
		}
	}
	// emit type definition
	if !query.Exec && !query.Flat {
		emit(xo.Template{
			Partial:  "typedef",
			Dest:     strings.ToLower(table.GoName) + ext,
			SortType: query.Type,
			SortName: query.Name,
			Data:     table,
		})
	}
	// build query params
	var params []QueryParam
	for _, param := range query.Params {
		params = append(params, QueryParam{
			Name:        param.Name,
			Type:        param.Type.Type,
			Interpolate: param.Interpolate,
			Join:        param.Join,
		})
	}
	// emit query
	emit(xo.Template{
		Partial:  "query",
		Dest:     strings.ToLower(table.GoName) + ext,
		SortType: query.Type,
		SortName: query.Name,
		Data: Query{
			Name:        buildQueryName(query),
			Query:       query.Query,
			Comments:    query.Comments,
			Params:      params,
			One:         query.Exec || query.Flat || query.One,
			Flat:        query.Flat,
			Exec:        query.Exec,
			Interpolate: query.Interpolate,
			Type:        table,
			Comment:     query.Comment,
		},
	})
	return nil
}

func buildQueryType(ctx context.Context, query xo.Query) (Table, error) {
	tf := camelExport
	if query.Flat {
		tf = camel
	}
	var fields []Field
	for _, z := range query.Fields {
		f, err := convertField(ctx, tf, z)
		if err != nil {
			return Table{}, err
		}
		// dont use convertField; the types are already provided by the user
		if query.ManualFields {
			f = Field{
				GoName:  z.Name,
				SQLName: snake(z.Name),
				Type:    z.Type.Type,
			}
		}
		fields = append(fields, f)
	}
	sqlName := snake(query.Type)
	return Table{
		GoName:  query.Type,
		SQLName: sqlName,
		Fields:  fields,
		Comment: query.TypeComment,
	}, nil
}

// buildQueryName builds a name for the query.
func buildQueryName(query xo.Query) string {
	if query.Name != "" {
		return query.Name
	}
	// generate name if not specified
	name := query.Type
	if !query.One {
		name = inflector.Pluralize(name)
	}
	// add params
	if len(query.Params) == 0 {
		name = "Get" + name
	} else {
		name += "By"
		for _, p := range query.Params {
			name += camelExport(p.Name)
		}
	}
	return name
}

// emitSchema emits the xo schema for the template set.
func emitSchema(ctx context.Context, schema xo.Schema, proto map[string]typeEntry, emit func(xo.Template)) error {
	// emit enums
	for _, e := range schema.Enums {
		enum := convertEnum(e)
		emit(xo.Template{
			Partial:  "enum",
			Dest:     "enums" + ext,
			SortName: enum.GoName,
			Data:     enum,
		})
	}
	// emit tables
	var tables []Table
	for _, t := range schema.Tables {
		typeInfo, ok := proto[t.Name]
		if !ok {
			continue
		}
		table, err := convertTable(ctx, typeInfo, t)
		if err != nil {
			return err
		}
		// emit indexes
		for _, i := range t.Indexes {
			index, err := convertIndex(ctx, table, i)
			if err != nil {
				return err
			}
			table.Indexes = append(table.Indexes, index)
		}
		// emit fkeys
		for _, fk := range t.ForeignKeys {
			fkey, err := convertFKey(ctx, table, fk)
			if err != nil {
				return err
			}
			table.FKeys = append(table.FKeys, fkey)
		}
		emit(xo.Template{
			Dest:     strings.ToLower(table.GoName) + ext,
			Partial:  "typedef",
			SortType: table.Type,
			SortName: table.GoName,
			Data:     table,
		})
		tables = append(tables, table)
	}
	emit(xo.Template{
		Dest:    "interface" + ext,
		Partial: "interface",
		Data:    tables,
	})
	return nil
}

// convertEnum converts a xo.Enum.
func convertEnum(e xo.Enum) Enum {
	var vals []EnumValue
	goName := camelExport(e.Name)
	for _, v := range e.Values {
		name := camelExport(strings.ToLower(v.Name))
		if strings.HasSuffix(name, goName) && goName != name {
			name = strings.TrimSuffix(name, goName)
		}
		vals = append(vals, EnumValue{
			GoName:     name,
			SQLName:    v.Name,
			ConstValue: *v.ConstValue,
		})
	}
	return Enum{
		GoName:  goName,
		SQLName: e.Name,
		Values:  vals,
	}
}

// convertTable converts a xo.Table to a Table.
func convertTable(ctx context.Context, entry typeEntry, t xo.Table) (Table, error) {
	var cols, pkCols []Field
	for _, col := range t.Columns {
		f, err := convertField(ctx, camelExport, col)
		if err != nil {
			return Table{}, err
		}
		if ref, ok := getReference(ctx, entry, t, col); ok {
			f.Type = camelExport(singularize(ref))
		}
		cols = append(cols, f)
		if col.IsPrimary {
			pkCols = append(pkCols, f)
		}
	}
	return Table{
		GoName:      camelExport(singularize(t.Name)),
		SQLName:     t.Name,
		Fields:      cols,
		PrimaryKeys: pkCols,
		Manual:      t.Manual,
	}, nil
}

func convertIndex(ctx context.Context, _ Table, i xo.Index) (Index, error) {
	var fields []Field
	for _, z := range i.Fields {
		f, err := convertField(ctx, camelExport, z)
		if err != nil {
			return Index{}, err
		}
		fields = append(fields, f)
	}
	return Index{
		SQLName:   i.Name,
		Func:      camelExport(i.Func),
		Fields:    fields,
		IsUnique:  i.IsUnique,
		IsPrimary: i.IsPrimary,
	}, nil
}

func convertFKey(ctx context.Context, _ Table, fk xo.ForeignKey) (ForeignKey, error) {
	var fields, refFields []Field
	// convert fields
	for _, f := range fk.Fields {
		field, err := convertField(ctx, camelExport, f)
		if err != nil {
			return ForeignKey{}, err
		}
		fields = append(fields, field)
	}
	// convert ref fields
	for _, f := range fk.RefFields {
		refField, err := convertField(ctx, camelExport, f)
		if err != nil {
			return ForeignKey{}, err
		}
		refFields = append(refFields, refField)
	}
	return ForeignKey{
		GoName:    camelExport(fk.Func),
		SQLName:   fk.Name,
		Fields:    fields,
		RefTable:  camelExport(singularize(fk.RefTable)),
		RefFields: refFields,
		RefFunc:   camelExport(fk.RefFunc),
	}, nil
}

func convertField(ctx context.Context, tf transformFunc, f xo.Field) (Field, error) {
	typ, zero, err := goType(ctx, f.Type)
	if err != nil {
		return Field{}, err
	}
	return Field{
		Type:       typ,
		GoName:     tf(f.Name),
		SQLName:    f.Name,
		Zero:       zero,
		IsPrimary:  f.IsPrimary,
		IsSequence: f.IsSequence,
	}, nil
}

func getReference(ctx context.Context, entry typeEntry, t xo.Table, f xo.Field) (string, bool) {
	for _, fk := range t.ForeignKeys {
		if len(fk.Fields) != 1 || fk.Fields[0] != f {
			continue
		}
		field, _ := convertField(ctx, camelExport, f)
		if entry.Fields[field.GoName].Kind == "basic" {
			return "", false
		}
		return fk.RefTable, true
	}
	return "", false
}

func goType(ctx context.Context, typ xo.Type) (string, string, error) {
	driver, _, schema := xo.DriverDbSchema(ctx)
	var f func(xo.Type, string, string, string) (string, string, error)
	switch driver {
	case "mysql":
		f = loader.MysqlGoType
	case "oracle":
		f = loader.OracleGoType
	case "postgres":
		f = loader.PostgresGoType
	case "sqlite3":
		f = loader.Sqlite3GoType
	case "sqlserver":
		f = loader.SqlserverGoType
	default:
		return "", "", fmt.Errorf("unknown driver %q", driver)
	}
	return f(typ, schema, "int32", "uint32")
}

type transformFunc func(...string) string

func snake(names ...string) string {
	return snaker.CamelToSnake(strings.Join(names, "_"))
}

func camel(names ...string) string {
	return snaker.ForceLowerCamelIdentifier(strings.Join(names, "_"))
}

func camelExport(names ...string) string {
	return snaker.ForceCamelIdentifier(strings.Join(names, "_"))
}

const ext = ".xo.go"

// Funcs is a set of template funcs.
type Funcs struct {
	pkg      string
	conflict string
	proto    map[string]typeEntry
	fieldtag *template.Template
	// knownTypes is the collection of known Go types.
	knownTypes map[string]bool
	// shorts is the collection of Go style short names for types, mainly
	// used for use with declaring a func receiver on a type.
	shorts map[string]string
}

type typeEntry struct {
	PkgName  string                `json:"pkg_name"`
	PkgPath  string                `json:"pkg_path"`
	TypeName string                `json:"type"`
	Fields   map[string]fieldEntry `json:"fields,omitempty"`
}

type fieldEntry struct {
	PkgName string `json:"pkg_name,omitempty"`
	PkgPath string `json:"pkg_path,omitempty"`
	Type    string `json:"type"`
	Kind    string `json:"kind"`
	Array   bool   `json:"array,omitempty"`
	Map     bool   `json:"map,omitempty"`
}

// NewFuncs creates custom template funcs for the context.
func NewFuncs(ctx context.Context) (template.FuncMap, error) {
	// parse field tag template
	fieldtag, err := template.New("fieldtag").Parse(`json:"{{ .SQLName }}"`)
	if err != nil {
		return nil, err
	}
	proto, err := Proto(ctx)
	if err != nil {
		return nil, err
	}
	funcs := &Funcs{
		pkg:      filepath.Base(xo.Out(ctx)),
		conflict: Conflict(ctx),
		proto:    proto,
		fieldtag: fieldtag,
		shorts:   make(map[string]string),
	}
	return funcs.FuncMap(), nil
}

// FuncMap returns the func map.
func (f *Funcs) FuncMap() template.FuncMap {
	return template.FuncMap{
		// general
		"pkg":        f.pkgfn,
		"protonames": f.protonames,
		// func and query
		"method": f.method,
		"func":   f.funcfn,
		// type
		"params": f.params,
		"field":  f.field,
		"short":  f.short,
		"plural": f.plural,
		// protobuf interface
		"protoname":   f.protoname,
		"pb":          f.pb,
		"from_pb":     f.fromPB,
		"fields":      f.fields,
		"marshaler":   f.marshaler,
		"unmarshaler": f.unmarshaler,
		// helpers
		"has_prefix": hasPrefix,
		"check_name": checkName,
		"join":       join,
		"eval":       eval,
	}
}

// pkgfn returns the package name.
func (f *Funcs) pkgfn() string {
	return f.pkg
}

func (f *Funcs) protonames() []string {
	paths := make(map[string]bool, len(f.proto))
	for _, name := range f.proto {
		paths[name.PkgPath] = true
	}
	pathSlice := make([]string, 0, len(paths))
	for k := range paths {
		pathSlice = append(pathSlice, k)
	}
	sort.Strings(pathSlice)
	return pathSlice
}

func (f *Funcs) funcName(v interface{}) (string, error) {
	switch x := v.(type) {
	case string:
		return x, nil
	case Query:
		return x.Name, nil
	case Table:
		return x.GoName, nil
	case ForeignKey:
		return x.GoName, nil
	case Index:
		return x.Func, nil
	}
	return "", fmt.Errorf("unsupported type for func_name: %T", v)
}

// funcfn builds a func definition.
func (f *Funcs) funcfn(table Table, v interface{}) (string, error) {
	name, err := f.funcName(v)
	if err != nil {
		return "", err
	}
	var param, retVal []string
	param = append(param, "context.Context")
	switch x := v.(type) {
	case Query:
		// params
		for _, z := range x.Params {
			param = append(param, fmt.Sprintf("%s %s", z.Name, z.Type))
		}
		// returns
		switch {
		case x.Exec:
			retVal = append(retVal, "sql.Result")
		case x.Flat:
			for _, field := range table.Fields {
				retVal = append(retVal, f.typefn(field.Type))
			}
		case x.One:
			retVal = append(retVal, "*"+x.Type.GoName)
		default:
			retVal = append(retVal, "[]*"+x.Type.GoName)
		}
	case Index:
		// params
		param = append(param, f.params(x.Fields))
		// returns
		retTyp := "*" + table.GoName
		if !x.IsUnique {
			retTyp = "[]" + retTyp
		}
		retVal = append(retVal, retTyp)

	default:
		return "", fmt.Errorf("unsupported type for funcfn: %T", v)
	}
	retVal = append(retVal, "error")
	return fmt.Sprintf(
		"%s(%s) (%s)",
		name, strings.Join(param, ", "), strings.Join(retVal, ", "),
	), nil
}

// recv builds a receiver func definition.
func (f *Funcs) method(t Table, v interface{}, suffix string) (string, error) {
	name, err := f.funcName(v)
	if err != nil {
		return "", err
	}
	param := []string{"context.Context", "*" + t.GoName}
	// determine return types
	var retVal []string
	switch x := v.(type) {
	case ForeignKey:
		retVal = append(retVal, "*"+x.RefTable)
	}
	retVal = append(retVal, "error")
	// build
	return fmt.Sprintf(
		"%s(%s) (%s)",
		name+suffix, strings.Join(param, ", "), strings.Join(retVal, ", "),
	), nil
}

// names generates a list of names (excluding certain ones such as interpolated
// names).
func (f *Funcs) names(prefix string, z ...interface{}) (string, error) {
	var names []string
	for i, v := range z {
		switch x := v.(type) {
		case string:
			names = append(names, x)
		case Query:
		case Table:
			for _, p := range x.Fields {
				names = append(names, prefix+checkName(p.GoName))
			}
		case []Field:
			for _, p := range x {
				names = append(names, prefix+checkName(p.GoName))
			}
		case Index:
			names = append(names, f.params(x.Fields))
		default:
			return "", fmt.Errorf("unsupported type for namesfn (%d): %T", i, v)
		}
	}
	return strings.Join(names, ", "), nil
}

// params converts a list of fields into Go parameters.
func (f *Funcs) params(fields []Field) string {
	vals := make([]string, 0, len(fields))
	for _, field := range fields {
		vals = append(vals, f.typefn(field.Type))
	}
	return strings.Join(vals, ", ")
}

// typefn generates the Go type, prefixing the custom package name if applicable.
func (f *Funcs) typefn(typ string) string {
	if strings.Contains(typ, ".") {
		return typ
	}
	var prefix string
	for strings.HasPrefix(typ, "[]") {
		typ = typ[2:]
		prefix += "[]"
	}
	return prefix + typ
}

// field generates a field definition for a struct.
func (f *Funcs) field(field Field) (string, error) {
	buf := new(bytes.Buffer)
	if err := f.fieldtag.Funcs(f.FuncMap()).Execute(buf, field); err != nil {
		return "", err
	}
	var tag string
	if s := buf.String(); s != "" {
		tag = " `" + s + "`"
	}
	return fmt.Sprintf("\t%s %s%s // %s", field.GoName, f.typefn(field.Type), tag, field.SQLName), nil
}

// short generates a safe Go identifier for typ. typ is first checked
// against shorts, and if not found, then the value is calculated and
// stored in the shorts for future use.
//
// A short is the concatenation of the lowercase of the first character in
// the words comprising the name. For example, "MyCustomName" will have have
// the short of "mcn".
//
// If a generated short conflicts with a Go reserved name or a name used in
// the templates, then the corresponding value in goReservedNames map will be
// used.
//
// Generated shorts that have conflicts with any scopeConflicts member will
// have nameConflictSuffix appended.
func (f *Funcs) short(v interface{}) (string, error) {
	var n string
	switch x := v.(type) {
	case string:
		n = x
	case Table:
		n = x.GoName
	case Enum:
		n = x.GoName
	default:
		return "", fmt.Errorf("unsupported type for short: %T", v)
	}
	// check short name map
	name, ok := f.shorts[n]
	if !ok {
		// calc the short name
		var u []string
		for _, s := range strings.Split(strings.ToLower(snaker.CamelToSnake(n)), "_") {
			if len(s) > 0 && s != "id" {
				u = append(u, s[:1])
			}
		}
		// ensure no name conflict
		name = checkName(strings.Join(u, ""))
		// store back to short name map
		f.shorts[n] = name
	}
	// append suffix if conflict exists
	if _, ok := templateReservedNames[name]; ok {
		name += f.conflict
	}
	return name, nil
}

func (f *Funcs) plural(s string) string {
	return inflector.Pluralize(s)
}

func (f *Funcs) protoname(sqlName string) (string, error) {
	ie, ok := f.proto[sqlName]
	if !ok {
		return "", fmt.Errorf("could not find proto name for %s", sqlName)
	}
	return ie.PkgName + "." + ie.TypeName, nil
}

func (f *Funcs) fromPB(t Table, z Field) (string, error) {
	name := "pb." + z.GoName

	pbType, ok := f.proto[t.SQLName].Fields[z.GoName]
	if !ok {
		return "", fmt.Errorf("could not find field data for %s.%s", t.SQLName, z.GoName)
	}
	switch {
	case z.Type == "sql.NullTime":
		return "toNullTime(" + name + ")", nil
	case z.Type == "sql.NullString":
		return "toNullString(" + name + ")", nil
	case pbType.Kind == "basic" || !ok:
		return name, nil
	case pbType.Array && pbType.Kind == "enum":
		return fmt.Sprintf("convertEnum[%s.%s, %s](%s, 1)",
			pbType.PkgName, pbType.Type, z.Type[2:], name), nil
	case pbType.Array:
		return "nil", nil
	case pbType.PkgName == "timestamppb":
		return name + ".AsTime()", nil
	case pbType.PkgName == "durationpb":
		return "int64(" + name + ".AsDuration())", nil
	case z.Type == "[]byte" && pbType.Kind == "message":
		return "nil", nil
	default:
		return "New" + z.Type + "(" + name + ")", nil
	}
}

func (f *Funcs) pb(t Table, z Field) (string, error) {
	short, err := f.short(t)
	if err != nil {
		return "", err
	}
	name := short + "." + z.GoName

	pbType, ok := f.proto[t.SQLName].Fields[z.GoName]
	if !ok {
		return "", fmt.Errorf("could not find field data for %s.%s", t.SQLName, z.GoName)
	}
	switch {
	case z.Type == "sql.NullTime":
		return "toTimePB(" + name + ")", nil
	case z.Type == "sql.NullString":
		return "toStringPB(" + name + ")", nil
	case pbType.Kind == "basic" || !ok:
		return name, nil
	case pbType.Array && pbType.Kind == "enum":
		return fmt.Sprintf("convertEnum[%s, %s.%s](%s, -1)",
			z.Type[2:], pbType.PkgName, pbType.Type, name), nil
	case pbType.Array:
		return "nil", nil
	case pbType.PkgName == "timestamppb":
		return "timestamppb.New(" + name + ")", nil
	case pbType.PkgName == "durationpb":
		return "durationpb.New(time.Duration(" + name + "))", nil
	case z.Type == "[]byte" && pbType.Kind == "message":
		return "nil", nil
	default:
		return name + ".PB()", nil
	}
}

func (f *Funcs) fields(t Table, complex bool) ([]Field, error) {
	var fields []Field
	for _, z := range t.Fields[1:] {
		ok, err := f.isMsg(t, z)
		if err != nil {
			return nil, err
		}
		if ok == complex {
			fields = append(fields, z)
		}
	}
	return fields, nil
}

func (f *Funcs) marshaler(t Table, z Field) (string, error) {
	pbType, ok := f.proto[t.SQLName].Fields[z.GoName]
	if !ok {
		return "", fmt.Errorf("could not find field data for %s.%s", t.SQLName, z.GoName)
	}
	m := "json.Marshal"
	if pbType.Kind == "message" {
		switch {
		case pbType.Map:
			// Use json.Marshal for maps.
		case pbType.Array:
			m = "marshalArray"
		default:
			m = "protojson.Marshal"
		}
	}
	return m + "(pb." + z.GoName + ")", nil
}

func (f *Funcs) unmarshaler(t Table, z Field) (string, error) {
	pbType, ok := f.proto[t.SQLName].Fields[z.GoName]
	if !ok {
		return "", fmt.Errorf("could not find field data for %s.%s", t.SQLName, z.GoName)
	}
	m := "json.Unmarshal"
	typ := "&pb." + z.GoName
	if pbType.Kind == "message" {
		switch {
		case pbType.Map:
			// Use json.Unmarshal for maps.
		case pbType.Array:
			m = "unmarshalArray"
		default:
			m = "unmarshalMessage"
		}
	}
	short, err := f.short(t)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s(%s.%s, %s)", m, short, z.GoName, typ), nil
}

func (f *Funcs) isMsg(t Table, z Field) (bool, error) {
	pbType, ok := f.proto[t.SQLName].Fields[z.GoName]
	if !ok {
		return false, fmt.Errorf("could not find field data for %s.%s", t.SQLName, z.GoName)
	}
	if pbType.PkgName == "timestamppb" ||
		pbType.PkgName == "durationpb" {
		return false, nil
	}
	return pbType.Kind == "message", nil
}

func hasPrefix(s, prefix string) bool {
	return strings.HasPrefix(s, prefix)
}

func checkName(name string) string {
	if n, ok := goReservedNames[name]; ok {
		return n
	}
	return name
}

func join(v interface{}, sep string) (string, error) {
	switch x := v.(type) {
	case []string:
		return strings.Join(x, sep), nil
	case []Field:
		var fields []string
		for _, f := range x {
			fields = append(fields, f.GoName)
		}
		return strings.Join(fields, sep), nil
	}
	return "", fmt.Errorf("unsupported type for join: %T", v)
}

// eval evalutates a template s against v.
func eval(v interface{}, s string) (string, error) {
	tpl, err := template.New(fmt.Sprintf("[EVAL %q]", s)).Parse(s)
	if err != nil {
		return "", err
	}
	buf := new(bytes.Buffer)
	if err := tpl.Execute(buf, v); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// templateReservedNames are the template reserved names.
var templateReservedNames = map[string]bool{
	// variables
	"ctx":  true,
	"db":   true,
	"err":  true,
	"log":  true,
	"logf": true,
	"res":  true,
	"rows": true,

	// packages
	"context": true,
	"csv":     true,
	"driver":  true,
	"errors":  true,
	"fmt":     true,
	"hstore":  true,
	"regexp":  true,
	"sql":     true,
	"strings": true,
	"time":    true,
	"uuid":    true,
}

// goReservedNames is a map of of go reserved names to "safe" names.
var goReservedNames = map[string]string{
	"break":       "brk",
	"case":        "cs",
	"chan":        "chn",
	"const":       "cnst",
	"continue":    "cnt",
	"default":     "def",
	"defer":       "dfr",
	"else":        "els",
	"fallthrough": "flthrough",
	"for":         "fr",
	"func":        "fn",
	"go":          "goVal",
	"goto":        "gt",
	"if":          "ifVal",
	"import":      "imp",
	"interface":   "iface",
	"map":         "mp",
	"package":     "pkg",
	"range":       "rnge",
	"return":      "ret",
	"select":      "slct",
	"struct":      "strct",
	"switch":      "swtch",
	"type":        "typ",
	"var":         "vr",
	// go types
	"error":      "e",
	"bool":       "b",
	"string":     "str",
	"byte":       "byt",
	"rune":       "r",
	"uintptr":    "uptr",
	"int":        "i",
	"int8":       "i8",
	"int16":      "i16",
	"int32":      "i32",
	"int64":      "i64",
	"uint":       "u",
	"uint8":      "u8",
	"uint16":     "u16",
	"uint32":     "u32",
	"uint64":     "u64",
	"float32":    "z",
	"float64":    "f",
	"complex64":  "c",
	"complex128": "c128",
}

// Context keys.
var (
	ProtoKey      xo.ContextKey = "protobuf"
	ConflictKey   xo.ContextKey = "conflict"
	InitialismKey xo.ContextKey = "initialism"
)

// Proto returns the proto names json from the context
func Proto(ctx context.Context) (map[string]typeEntry, error) {
	s, _ := ctx.Value(ProtoKey).(string)
	proto := make(map[string]typeEntry)
	if err := json.Unmarshal([]byte(s), &proto); err != nil {
		return nil, fmt.Errorf("could not unmarshal proto: %w", err)
	}
	return proto, nil
}

// Conflict returns conflict from the context.
func Conflict(ctx context.Context) string {
	s, _ := ctx.Value(ConflictKey).(string)
	return s
}

// addInitialisms adds snaker initialisms from the context.
func addInitialisms(ctx context.Context) error {
	z := ctx.Value(InitialismKey)
	y, _ := z.([]string)
	var v []string
	for _, s := range y {
		if s != "" {
			v = append(v, s)
		}
	}
	return snaker.DefaultInitialisms.Add(v...)
}

// singularize singularizes s.
func singularize(s string) string {
	if i := strings.LastIndex(s, "_"); i != -1 {
		return s[:i+1] + inflector.Singularize(s[i+1:])
	}
	return inflector.Singularize(s)
}

// EnumValue is a enum value template.
type EnumValue struct {
	GoName     string
	SQLName    string
	ConstValue int
}

// Enum is a enum type template.
type Enum struct {
	GoName  string
	SQLName string
	Values  []EnumValue
	Comment string
}

// Table is a type (ie, table/view/custom query) template.
type Table struct {
	Type        string
	GoName      string
	SQLName     string
	PrimaryKeys []Field
	Fields      []Field
	Manual      bool
	Comment     string
	FKeys       []ForeignKey
	Indexes     []Index
}

// ForeignKey is a foreign key template.
type ForeignKey struct {
	GoName    string
	SQLName   string
	Fields    []Field
	RefTable  string
	RefFields []Field
	RefFunc   string
	Comment   string
}

// Index is an index template.
type Index struct {
	SQLName   string
	Func      string
	Fields    []Field
	IsUnique  bool
	IsPrimary bool
	Comment   string
}

// Field is a field template.
type Field struct {
	GoName     string
	SQLName    string
	Type       string
	Zero       string
	IsPrimary  bool
	IsSequence bool
	Comment    string
}

// QueryParam is a custom query parameter template.
type QueryParam struct {
	Name        string
	Type        string
	Interpolate bool
	Join        bool
}

// Query is a custom query template.
type Query struct {
	Name        string
	Query       []string
	Comments    []string
	Params      []QueryParam
	One         bool
	Flat        bool
	Exec        bool
	Interpolate bool
	Type        Table
	Comment     string
}
