// Package postgres contains generated code from xo.
package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"

	"bnk.to/core/tools/db"
)

func (repo *Repository) InsertRevolvingAccount(ctx context.Context, ra *db.RevolvingAccount) error {
	const stmt = `INSERT INTO revolving_accounts
		(account_id, client_id, holder_type, notes, status, sub_status, max_credit, available_credit, consumed_credit, exposure_limit_type, approve_time, start_time, close_time, expire_time, create_time, update_time)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
		RETURNING id`
	var id int
	row := repo.db.QueryRowContext(
		ctx, stmt,
		ra.AccountID, ra.ClientID, ra.HolderType, ra.Notes, ra.Status, ra.SubStatus, ra.MaxCredit, ra.AvailableCredit, ra.ConsumedCredit, ra.ExposureLimitType, ra.ApproveTime, ra.StartTime, ra.CloseTime, ra.ExpireTime, ra.CreateTime, ra.UpdateTime,
	)
	if err := row.Scan(&id); err != nil {
		return err
	}
	return nil
}

func (repo *Repository) ListRevolvingAccounts(ctx context.Context, filter string, pageSize int32, orderBy string, after *db.ListPosition) (db.ListStat, []*db.RevolvingAccount, *db.ListPosition, error) {
	if filter != "" {
		return db.ListStat{}, nil, nil, fmt.Errorf("filter is unimplemented")
	}
	if orderBy == "" {
		orderBy = "id"
	}
	whereClause := `
		(
			(all_entries.ordered_idx > $2) OR
			(all_entries.ordered_idx = $2 AND all_entries.id > $3)
		)
	`
	if after == nil {
		// Use placeholder values but always evaluate to true.
		whereClause = "$2::INTEGER = $3"
		after = &db.ListPosition{
			Data: 0,
			ID:   0,
		}
	}
	const stmt = `WITH all_entries AS (
			SELECT
				quote_ident($1) AS ordered_idx, revolving_accounts.id,

				revolving_accounts.account_id,
				revolving_accounts.client_id,
				revolving_accounts.holder_type,
				revolving_accounts.notes,
				revolving_accounts.status,
				revolving_accounts.sub_status,
				revolving_accounts.max_credit,
				revolving_accounts.available_credit,
				revolving_accounts.consumed_credit,
				revolving_accounts.exposure_limit_type,
				revolving_accounts.approve_time,
				revolving_accounts.start_time,
				revolving_accounts.close_time,
				revolving_accounts.expire_time,
				revolving_accounts.create_time,
				revolving_accounts.update_time
			FROM
				revolving_accounts
			WHERE
				%s
		), all_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				all_entries
		), filtered AS (
			SELECT
				*
			FROM
				all_entries
			WHERE %s
		), filtered_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				filtered
		)
		SELECT
			all_count.count, filtered_count.count,
			NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
		FROM
			all_count
			CROSS JOIN filtered_count
		UNION ALL
		(
			SELECT
				*
			FROM
				all_count
				CROSS JOIN filtered_count
				CROSS JOIN filtered
			ORDER BY
				quote_ident($1), filtered.id
			LIMIT
				$4
		)`

	filterSQL := "TRUE" // TODO
	query := fmt.Sprintf(stmt, filterSQL, whereClause)
	rows, err := repo.db.QueryContext(ctx, query, "revolving_accounts."+orderBy, after.Data, after.ID, pageSize)
	if err != nil {
		return db.ListStat{}, nil, nil, err
	}

	defer rows.Close()
	result := make([]*db.RevolvingAccount, 0, pageSize)
	var nextPos db.ListPosition
	var listStat db.ListStat
	if !rows.Next() {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	var x any
	if err := rows.Scan(
		&listStat.Total, &listStat.Remaining,
		&x, &x,
		&x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x,
	); err != nil {
		return db.ListStat{}, nil, nil, err
	}
	for rows.Next() {
		var next db.RevolvingAccount
		if err := rows.Scan(
			&listStat.Total, &listStat.Remaining,
			&nextPos.Data, &nextPos.ID,
			&next.AccountID, &next.ClientID, &next.HolderType, &next.Notes, &next.Status, &next.SubStatus, &next.MaxCredit, &next.AvailableCredit, &next.ConsumedCredit, &next.ExposureLimitType, &next.ApproveTime, &next.StartTime, &next.CloseTime, &next.ExpireTime, &next.CreateTime, &next.UpdateTime,
		); err != nil {
			return db.ListStat{}, nil, nil, err
		}
		result = append(result, &next)
	}
	if rows.Err() != nil {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	return listStat, result, &nextPos, nil
}

func (repo *Repository) RevolvingAccountByID(ctx context.Context, id int32) (*db.RevolvingAccount, error) {
	const stmt = `SELECT
		revolving_accounts.id,

		revolving_accounts.account_id,
		revolving_accounts.client_id,
		revolving_accounts.holder_type,
		revolving_accounts.notes,
		revolving_accounts.status,
		revolving_accounts.sub_status,
		revolving_accounts.max_credit,
		revolving_accounts.available_credit,
		revolving_accounts.consumed_credit,
		revolving_accounts.exposure_limit_type,
		revolving_accounts.approve_time,
		revolving_accounts.start_time,
		revolving_accounts.close_time,
		revolving_accounts.expire_time,
		revolving_accounts.create_time,
		revolving_accounts.update_time
	FROM
		revolving_accounts
	WHERE
		id = $1`

	var ra db.RevolvingAccount
	row := repo.db.QueryRowContext(ctx, stmt, id)
	if err := row.Scan(
		&ra.ID,
		&ra.AccountID, &ra.ClientID, &ra.HolderType, &ra.Notes, &ra.Status, &ra.SubStatus, &ra.MaxCredit, &ra.AvailableCredit, &ra.ConsumedCredit, &ra.ExposureLimitType, &ra.ApproveTime, &ra.StartTime, &ra.CloseTime, &ra.ExpireTime, &ra.CreateTime, &ra.UpdateTime,
	); err != nil {
		return nil, err
	}

	return &ra, nil
}

func (repo *Repository) UpdateRevolvingAccountByID(ctx context.Context, ra *db.RevolvingAccount) error {
	const stmt = `UPDATE revolving_accounts
	SET account_id=$1,
		client_id=$2,
		holder_type=$3,
		notes=$4,
		status=$5,
		sub_status=$6,
		max_credit=$7,
		available_credit=$8,
		consumed_credit=$9,
		exposure_limit_type=$10,
		approve_time=$11,
		start_time=$12,
		close_time=$13,
		expire_time=$14,
		update_time=$15
	WHERE id = $16`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		ra.AccountID, ra.ClientID, ra.HolderType, ra.Notes, ra.Status, ra.SubStatus, ra.MaxCredit, ra.AvailableCredit, ra.ConsumedCredit, ra.ExposureLimitType, ra.ApproveTime, ra.StartTime, ra.CloseTime, ra.ExpireTime, ra.UpdateTime, ra.ID,
	)
	return err
}

func (repo *Repository) DeleteRevolvingAccountByID(ctx context.Context, id int32) error {
	const stmt = `DELETE FROM revolving_accounts
	WHERE id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		id,
	)
	return err
}

func (repo *Repository) RevolvingAccountByAccountID(ctx context.Context, accountID string) (*db.RevolvingAccount, error) {
	const stmt = `SELECT
		revolving_accounts.id,

		revolving_accounts.account_id,
		revolving_accounts.client_id,
		revolving_accounts.holder_type,
		revolving_accounts.notes,
		revolving_accounts.status,
		revolving_accounts.sub_status,
		revolving_accounts.max_credit,
		revolving_accounts.available_credit,
		revolving_accounts.consumed_credit,
		revolving_accounts.exposure_limit_type,
		revolving_accounts.approve_time,
		revolving_accounts.start_time,
		revolving_accounts.close_time,
		revolving_accounts.expire_time,
		revolving_accounts.create_time,
		revolving_accounts.update_time
	FROM
		revolving_accounts
	WHERE
		account_id = $1`

	var ra db.RevolvingAccount
	row := repo.db.QueryRowContext(ctx, stmt, accountID)
	if err := row.Scan(
		&ra.ID,
		&ra.AccountID, &ra.ClientID, &ra.HolderType, &ra.Notes, &ra.Status, &ra.SubStatus, &ra.MaxCredit, &ra.AvailableCredit, &ra.ConsumedCredit, &ra.ExposureLimitType, &ra.ApproveTime, &ra.StartTime, &ra.CloseTime, &ra.ExpireTime, &ra.CreateTime, &ra.UpdateTime,
	); err != nil {
		return nil, err
	}

	return &ra, nil
}

func (repo *Repository) UpdateRevolvingAccountByAccountID(ctx context.Context, ra *db.RevolvingAccount) error {
	const stmt = `UPDATE revolving_accounts
	SET account_id=$1,
		client_id=$2,
		holder_type=$3,
		notes=$4,
		status=$5,
		sub_status=$6,
		max_credit=$7,
		available_credit=$8,
		consumed_credit=$9,
		exposure_limit_type=$10,
		approve_time=$11,
		start_time=$12,
		close_time=$13,
		expire_time=$14,
		update_time=$15
	WHERE account_id = $16`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		ra.AccountID, ra.ClientID, ra.HolderType, ra.Notes, ra.Status, ra.SubStatus, ra.MaxCredit, ra.AvailableCredit, ra.ConsumedCredit, ra.ExposureLimitType, ra.ApproveTime, ra.StartTime, ra.CloseTime, ra.ExpireTime, ra.UpdateTime, ra.AccountID,
	)
	return err
}

func (repo *Repository) DeleteRevolvingAccountByAccountID(ctx context.Context, accountID string) error {
	const stmt = `DELETE FROM revolving_accounts
	WHERE account_id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		accountID,
	)
	return err
}
