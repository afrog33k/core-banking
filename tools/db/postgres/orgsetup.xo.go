// Package postgres contains generated code from xo.
package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"

	"bnk.to/core/tools/db"
)

func (repo *Repository) InsertOrgSetup(ctx context.Context, os *db.OrgSetup) error {
	const stmt = `WITH org_setups_defaults AS (
		INSERT INTO org_defaults
			(client_role_id, client_state, group_role_id, line_of_credit_state, transaction_channel_id)
			VALUES ($1, $2, $3, $4, $5)
			RETURNING id
	)
	INSERT INTO org_setups
		(accounting_cut_off_time, arrears_days_before_write_off, assignment_constraints, automated_accounting_closures_interval, client_id_format, group_id_format, line_of_credit_id_format, date_formats, enabled_components, dashboard_components, decimal_separator, defaults, client_checks, client_constraint_action, end_of_day_mode, exposure_amount, exposure_type, min_group_size_limit, max_group_size_limit, group_size_limit_type, inter_branch_transfer_gl_account_id, max_allowed_id_document_attachments, max_allowed_journal_entry_document_attachments, max_allowed_undo_closure_period, max_client_groups, max_loans, allow_other_id_documents, overdraft_interest_date, min_disbursal_approval_required, min_loan_approval_required)
		SELECT $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, org_setups_defaults.id, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34
		FROM org_setups_defaults
		RETURNING id`
	var id int
	row := repo.db.QueryRowContext(
		ctx, stmt,
		os.Defaults.ClientRoleID, os.Defaults.ClientState, os.Defaults.GroupRoleID, os.Defaults.LineOfCreditState, os.Defaults.TransactionChannelID,
		os.AccountingCutOffTime, os.ArrearsDaysBeforeWriteOff, os.AssignmentConstraints, os.AutomatedAccountingClosuresInterval, os.ClientIDFormat, os.GroupIDFormat, os.LineOfCreditIDFormat, os.DateFormats, os.EnabledComponents, os.DashboardComponents, os.DecimalSeparator, os.ClientChecks, os.ClientConstraintAction, os.EndOfDayMode, os.ExposureAmount, os.ExposureType, os.MinGroupSizeLimit, os.MaxGroupSizeLimit, os.GroupSizeLimitType, os.InterBranchTransferGLAccountID, os.MaxAllowedIDDocumentAttachments, os.MaxAllowedJournalEntryDocumentAttachments, os.MaxAllowedUndoClosurePeriod, os.MaxClientGroups, os.MaxLoans, os.AllowOtherIDDocuments, os.OverdraftInterestDate, os.MinDisbursalApprovalRequired, os.MinLoanApprovalRequired,
	)
	if err := row.Scan(&id); err != nil {
		return err
	}
	return nil
}

func (repo *Repository) ListOrgSetups(ctx context.Context, filter string, pageSize int32, orderBy string, after *db.ListPosition) (db.ListStat, []*db.OrgSetup, *db.ListPosition, error) {
	if filter != "" {
		return db.ListStat{}, nil, nil, fmt.Errorf("filter is unimplemented")
	}
	if orderBy == "" {
		orderBy = "id"
	}
	whereClause := `
		(
			(all_entries.ordered_idx > $2) OR
			(all_entries.ordered_idx = $2 AND all_entries.id > $3)
		)
	`
	if after == nil {
		// Use placeholder values but always evaluate to true.
		whereClause = "$2::INTEGER = $3"
		after = &db.ListPosition{
			Data: 0,
			ID:   0,
		}
	}
	const stmt = `WITH all_entries AS (
			SELECT
				quote_ident($1) AS ordered_idx, org_setups.id,

				org_setups_defaults_tbl.client_role_id,
				org_setups_defaults_tbl.client_state,
				org_setups_defaults_tbl.group_role_id,
				org_setups_defaults_tbl.line_of_credit_state,
				org_setups_defaults_tbl.transaction_channel_id,

				org_setups.accounting_cut_off_time,
				org_setups.arrears_days_before_write_off,
				org_setups.assignment_constraints,
				org_setups.automated_accounting_closures_interval,
				org_setups.client_id_format,
				org_setups.group_id_format,
				org_setups.line_of_credit_id_format,
				org_setups.date_formats,
				org_setups.enabled_components,
				org_setups.dashboard_components,
				org_setups.decimal_separator,
				org_setups.client_checks,
				org_setups.client_constraint_action,
				org_setups.end_of_day_mode,
				org_setups.exposure_amount,
				org_setups.exposure_type,
				org_setups.min_group_size_limit,
				org_setups.max_group_size_limit,
				org_setups.group_size_limit_type,
				org_setups.inter_branch_transfer_gl_account_id,
				org_setups.max_allowed_id_document_attachments,
				org_setups.max_allowed_journal_entry_document_attachments,
				org_setups.max_allowed_undo_closure_period,
				org_setups.max_client_groups,
				org_setups.max_loans,
				org_setups.allow_other_id_documents,
				org_setups.overdraft_interest_date,
				org_setups.min_disbursal_approval_required,
				org_setups.min_loan_approval_required
			FROM
				org_setups
				JOIN org_defaults AS org_setups_defaults_tbl ON org_setups_defaults_tbl.id = org_setups.defaults
			WHERE
				%s
		), all_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				all_entries
		), filtered AS (
			SELECT
				*
			FROM
				all_entries
			WHERE %s
		), filtered_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				filtered
		)
		SELECT
			all_count.count, filtered_count.count,
			NULL, NULL,
			NULL, NULL, NULL, NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
		FROM
			all_count
			CROSS JOIN filtered_count
		UNION ALL
		(
			SELECT
				*
			FROM
				all_count
				CROSS JOIN filtered_count
				CROSS JOIN filtered
			ORDER BY
				quote_ident($1), filtered.id
			LIMIT
				$4
		)`

	filterSQL := "TRUE" // TODO
	query := fmt.Sprintf(stmt, filterSQL, whereClause)
	rows, err := repo.db.QueryContext(ctx, query, "org_setups."+orderBy, after.Data, after.ID, pageSize)
	if err != nil {
		return db.ListStat{}, nil, nil, err
	}

	defer rows.Close()
	result := make([]*db.OrgSetup, 0, pageSize)
	var nextPos db.ListPosition
	var listStat db.ListStat
	if !rows.Next() {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	var x any
	if err := rows.Scan(
		&listStat.Total, &listStat.Remaining,
		&x, &x,
		&x, &x, &x, &x, &x,
		&x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x,
	); err != nil {
		return db.ListStat{}, nil, nil, err
	}
	for rows.Next() {
		var next db.OrgSetup
		if err := rows.Scan(
			&listStat.Total, &listStat.Remaining,
			&nextPos.Data, &nextPos.ID,
			&next.Defaults.ClientRoleID, &next.Defaults.ClientState, &next.Defaults.GroupRoleID, &next.Defaults.LineOfCreditState, &next.Defaults.TransactionChannelID,
			&next.AccountingCutOffTime, &next.ArrearsDaysBeforeWriteOff, &next.AssignmentConstraints, &next.AutomatedAccountingClosuresInterval, &next.ClientIDFormat, &next.GroupIDFormat, &next.LineOfCreditIDFormat, &next.DateFormats, &next.EnabledComponents, &next.DashboardComponents, &next.DecimalSeparator, &next.ClientChecks, &next.ClientConstraintAction, &next.EndOfDayMode, &next.ExposureAmount, &next.ExposureType, &next.MinGroupSizeLimit, &next.MaxGroupSizeLimit, &next.GroupSizeLimitType, &next.InterBranchTransferGLAccountID, &next.MaxAllowedIDDocumentAttachments, &next.MaxAllowedJournalEntryDocumentAttachments, &next.MaxAllowedUndoClosurePeriod, &next.MaxClientGroups, &next.MaxLoans, &next.AllowOtherIDDocuments, &next.OverdraftInterestDate, &next.MinDisbursalApprovalRequired, &next.MinLoanApprovalRequired,
		); err != nil {
			return db.ListStat{}, nil, nil, err
		}
		result = append(result, &next)
	}
	if rows.Err() != nil {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	return listStat, result, &nextPos, nil
}

func (repo *Repository) OrgSetupByID(ctx context.Context, id int32) (*db.OrgSetup, error) {
	const stmt = `SELECT
		org_setups.id,

		org_setups_defaults_tbl.client_role_id,
		org_setups_defaults_tbl.client_state,
		org_setups_defaults_tbl.group_role_id,
		org_setups_defaults_tbl.line_of_credit_state,
		org_setups_defaults_tbl.transaction_channel_id,

		org_setups.accounting_cut_off_time,
		org_setups.arrears_days_before_write_off,
		org_setups.assignment_constraints,
		org_setups.automated_accounting_closures_interval,
		org_setups.client_id_format,
		org_setups.group_id_format,
		org_setups.line_of_credit_id_format,
		org_setups.date_formats,
		org_setups.enabled_components,
		org_setups.dashboard_components,
		org_setups.decimal_separator,
		org_setups.client_checks,
		org_setups.client_constraint_action,
		org_setups.end_of_day_mode,
		org_setups.exposure_amount,
		org_setups.exposure_type,
		org_setups.min_group_size_limit,
		org_setups.max_group_size_limit,
		org_setups.group_size_limit_type,
		org_setups.inter_branch_transfer_gl_account_id,
		org_setups.max_allowed_id_document_attachments,
		org_setups.max_allowed_journal_entry_document_attachments,
		org_setups.max_allowed_undo_closure_period,
		org_setups.max_client_groups,
		org_setups.max_loans,
		org_setups.allow_other_id_documents,
		org_setups.overdraft_interest_date,
		org_setups.min_disbursal_approval_required,
		org_setups.min_loan_approval_required
	FROM
		org_setups
		JOIN org_defaults AS org_setups_defaults_tbl ON org_setups_defaults_tbl.id = org_setups.defaults
	WHERE
		id = $1`

	var os db.OrgSetup
	row := repo.db.QueryRowContext(ctx, stmt, id)
	if err := row.Scan(
		&os.ID,
		&os.Defaults.ClientRoleID, &os.Defaults.ClientState, &os.Defaults.GroupRoleID, &os.Defaults.LineOfCreditState, &os.Defaults.TransactionChannelID,
		&os.AccountingCutOffTime, &os.ArrearsDaysBeforeWriteOff, &os.AssignmentConstraints, &os.AutomatedAccountingClosuresInterval, &os.ClientIDFormat, &os.GroupIDFormat, &os.LineOfCreditIDFormat, &os.DateFormats, &os.EnabledComponents, &os.DashboardComponents, &os.DecimalSeparator, &os.ClientChecks, &os.ClientConstraintAction, &os.EndOfDayMode, &os.ExposureAmount, &os.ExposureType, &os.MinGroupSizeLimit, &os.MaxGroupSizeLimit, &os.GroupSizeLimitType, &os.InterBranchTransferGLAccountID, &os.MaxAllowedIDDocumentAttachments, &os.MaxAllowedJournalEntryDocumentAttachments, &os.MaxAllowedUndoClosurePeriod, &os.MaxClientGroups, &os.MaxLoans, &os.AllowOtherIDDocuments, &os.OverdraftInterestDate, &os.MinDisbursalApprovalRequired, &os.MinLoanApprovalRequired,
	); err != nil {
		return nil, err
	}

	return &os, nil
}

func (repo *Repository) UpdateOrgSetupByID(ctx context.Context, os *db.OrgSetup) error {
	const stmt = `WITH org_setups_org_defaults AS (
		UPDATE org_defaults
		SET client_role_id=$1,
			client_state=$2,
			group_role_id=$3,
			line_of_credit_state=$4,
			transaction_channel_id=$5
		FROM org_setups
		WHERE org_setups.defaults = org_defaults.id AND
			org_setups.id = $6
	)
	UPDATE org_setups
	SET accounting_cut_off_time=$7,
		arrears_days_before_write_off=$8,
		assignment_constraints=$9,
		automated_accounting_closures_interval=$10,
		client_id_format=$11,
		group_id_format=$12,
		line_of_credit_id_format=$13,
		date_formats=$14,
		enabled_components=$15,
		dashboard_components=$16,
		decimal_separator=$17,
		client_checks=$18,
		client_constraint_action=$19,
		end_of_day_mode=$20,
		exposure_amount=$21,
		exposure_type=$22,
		min_group_size_limit=$23,
		max_group_size_limit=$24,
		group_size_limit_type=$25,
		inter_branch_transfer_gl_account_id=$26,
		max_allowed_id_document_attachments=$27,
		max_allowed_journal_entry_document_attachments=$28,
		max_allowed_undo_closure_period=$29,
		max_client_groups=$30,
		max_loans=$31,
		allow_other_id_documents=$32,
		overdraft_interest_date=$33,
		min_disbursal_approval_required=$34,
		min_loan_approval_required=$35
	WHERE id = $36`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		os.Defaults.ClientRoleID, os.Defaults.ClientState, os.Defaults.GroupRoleID, os.Defaults.LineOfCreditState, os.Defaults.TransactionChannelID, os.ID,
		os.AccountingCutOffTime, os.ArrearsDaysBeforeWriteOff, os.AssignmentConstraints, os.AutomatedAccountingClosuresInterval, os.ClientIDFormat, os.GroupIDFormat, os.LineOfCreditIDFormat, os.DateFormats, os.EnabledComponents, os.DashboardComponents, os.DecimalSeparator, os.ClientChecks, os.ClientConstraintAction, os.EndOfDayMode, os.ExposureAmount, os.ExposureType, os.MinGroupSizeLimit, os.MaxGroupSizeLimit, os.GroupSizeLimitType, os.InterBranchTransferGLAccountID, os.MaxAllowedIDDocumentAttachments, os.MaxAllowedJournalEntryDocumentAttachments, os.MaxAllowedUndoClosurePeriod, os.MaxClientGroups, os.MaxLoans, os.AllowOtherIDDocuments, os.OverdraftInterestDate, os.MinDisbursalApprovalRequired, os.MinLoanApprovalRequired, os.ID,
	)
	return err
}

func (repo *Repository) DeleteOrgSetupByID(ctx context.Context, id int32) error {
	const stmt = `WITH org_setups_org_defaults AS (
		DELETE FROM org_defaults
		USING org_setups
		WHERE org_setups.defaults = org_defaults.id AND
			org_setups.id = $1
	)
	DELETE FROM org_setups
	WHERE id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		id,
	)
	return err
}
