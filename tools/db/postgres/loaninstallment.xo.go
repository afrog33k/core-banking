// Package postgres contains generated code from xo.
package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"

	"bnk.to/core/tools/db"
)

func (repo *Repository) InsertLoanInstallment(ctx context.Context, li *db.LoanInstallment) error {
	const stmt = `INSERT INTO loan_installments
		(installment_id, fees, interest, is_payment_holiday, pay_time, order, parent_account_id, penalty, principal, due_time, repay_time, state)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
		RETURNING id`
	var id int
	row := repo.db.QueryRowContext(
		ctx, stmt,
		li.InstallmentID, li.Fees, li.Interest, li.IsPaymentHoliday, li.PayTime, li.Order, li.ParentAccountID, li.Penalty, li.Principal, li.DueTime, li.RepayTime, li.State,
	)
	if err := row.Scan(&id); err != nil {
		return err
	}
	return nil
}

func (repo *Repository) ListLoanInstallments(ctx context.Context, filter string, pageSize int32, orderBy string, after *db.ListPosition) (db.ListStat, []*db.LoanInstallment, *db.ListPosition, error) {
	if filter != "" {
		return db.ListStat{}, nil, nil, fmt.Errorf("filter is unimplemented")
	}
	if orderBy == "" {
		orderBy = "id"
	}
	whereClause := `
		(
			(all_entries.ordered_idx > $2) OR
			(all_entries.ordered_idx = $2 AND all_entries.id > $3)
		)
	`
	if after == nil {
		// Use placeholder values but always evaluate to true.
		whereClause = "$2::INTEGER = $3"
		after = &db.ListPosition{
			Data: 0,
			ID:   0,
		}
	}
	const stmt = `WITH all_entries AS (
			SELECT
				quote_ident($1) AS ordered_idx, loan_installments.id,

				loan_installments.installment_id,
				loan_installments.fees,
				loan_installments.interest,
				loan_installments.is_payment_holiday,
				loan_installments.pay_time,
				loan_installments.order,
				loan_installments.parent_account_id,
				loan_installments.penalty,
				loan_installments.principal,
				loan_installments.due_time,
				loan_installments.repay_time,
				loan_installments.state
			FROM
				loan_installments
			WHERE
				%s
		), all_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				all_entries
		), filtered AS (
			SELECT
				*
			FROM
				all_entries
			WHERE %s
		), filtered_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				filtered
		)
		SELECT
			all_count.count, filtered_count.count,
			NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
		FROM
			all_count
			CROSS JOIN filtered_count
		UNION ALL
		(
			SELECT
				*
			FROM
				all_count
				CROSS JOIN filtered_count
				CROSS JOIN filtered
			ORDER BY
				quote_ident($1), filtered.id
			LIMIT
				$4
		)`

	filterSQL := "TRUE" // TODO
	query := fmt.Sprintf(stmt, filterSQL, whereClause)
	rows, err := repo.db.QueryContext(ctx, query, "loan_installments."+orderBy, after.Data, after.ID, pageSize)
	if err != nil {
		return db.ListStat{}, nil, nil, err
	}

	defer rows.Close()
	result := make([]*db.LoanInstallment, 0, pageSize)
	var nextPos db.ListPosition
	var listStat db.ListStat
	if !rows.Next() {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	var x any
	if err := rows.Scan(
		&listStat.Total, &listStat.Remaining,
		&x, &x,
		&x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x,
	); err != nil {
		return db.ListStat{}, nil, nil, err
	}
	for rows.Next() {
		var next db.LoanInstallment
		if err := rows.Scan(
			&listStat.Total, &listStat.Remaining,
			&nextPos.Data, &nextPos.ID,
			&next.InstallmentID, &next.Fees, &next.Interest, &next.IsPaymentHoliday, &next.PayTime, &next.Order, &next.ParentAccountID, &next.Penalty, &next.Principal, &next.DueTime, &next.RepayTime, &next.State,
		); err != nil {
			return db.ListStat{}, nil, nil, err
		}
		result = append(result, &next)
	}
	if rows.Err() != nil {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	return listStat, result, &nextPos, nil
}

func (repo *Repository) LoanInstallmentByID(ctx context.Context, id int32) (*db.LoanInstallment, error) {
	const stmt = `SELECT
		loan_installments.id,

		loan_installments.installment_id,
		loan_installments.fees,
		loan_installments.interest,
		loan_installments.is_payment_holiday,
		loan_installments.pay_time,
		loan_installments.order,
		loan_installments.parent_account_id,
		loan_installments.penalty,
		loan_installments.principal,
		loan_installments.due_time,
		loan_installments.repay_time,
		loan_installments.state
	FROM
		loan_installments
	WHERE
		id = $1`

	var li db.LoanInstallment
	row := repo.db.QueryRowContext(ctx, stmt, id)
	if err := row.Scan(
		&li.ID,
		&li.InstallmentID, &li.Fees, &li.Interest, &li.IsPaymentHoliday, &li.PayTime, &li.Order, &li.ParentAccountID, &li.Penalty, &li.Principal, &li.DueTime, &li.RepayTime, &li.State,
	); err != nil {
		return nil, err
	}

	return &li, nil
}

func (repo *Repository) UpdateLoanInstallmentByID(ctx context.Context, li *db.LoanInstallment) error {
	const stmt = `UPDATE loan_installments
	SET installment_id=$1,
		fees=$2,
		interest=$3,
		is_payment_holiday=$4,
		pay_time=$5,
		order=$6,
		parent_account_id=$7,
		penalty=$8,
		principal=$9,
		due_time=$10,
		repay_time=$11,
		state=$12
	WHERE id = $13`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		li.InstallmentID, li.Fees, li.Interest, li.IsPaymentHoliday, li.PayTime, li.Order, li.ParentAccountID, li.Penalty, li.Principal, li.DueTime, li.RepayTime, li.State, li.ID,
	)
	return err
}

func (repo *Repository) DeleteLoanInstallmentByID(ctx context.Context, id int32) error {
	const stmt = `DELETE FROM loan_installments
	WHERE id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		id,
	)
	return err
}

func (repo *Repository) LoanInstallmentByInstallmentID(ctx context.Context, installmentID string) (*db.LoanInstallment, error) {
	const stmt = `SELECT
		loan_installments.id,

		loan_installments.installment_id,
		loan_installments.fees,
		loan_installments.interest,
		loan_installments.is_payment_holiday,
		loan_installments.pay_time,
		loan_installments.order,
		loan_installments.parent_account_id,
		loan_installments.penalty,
		loan_installments.principal,
		loan_installments.due_time,
		loan_installments.repay_time,
		loan_installments.state
	FROM
		loan_installments
	WHERE
		installment_id = $1`

	var li db.LoanInstallment
	row := repo.db.QueryRowContext(ctx, stmt, installmentID)
	if err := row.Scan(
		&li.ID,
		&li.InstallmentID, &li.Fees, &li.Interest, &li.IsPaymentHoliday, &li.PayTime, &li.Order, &li.ParentAccountID, &li.Penalty, &li.Principal, &li.DueTime, &li.RepayTime, &li.State,
	); err != nil {
		return nil, err
	}

	return &li, nil
}

func (repo *Repository) UpdateLoanInstallmentByInstallmentID(ctx context.Context, li *db.LoanInstallment) error {
	const stmt = `UPDATE loan_installments
	SET installment_id=$1,
		fees=$2,
		interest=$3,
		is_payment_holiday=$4,
		pay_time=$5,
		order=$6,
		parent_account_id=$7,
		penalty=$8,
		principal=$9,
		due_time=$10,
		repay_time=$11,
		state=$12
	WHERE installment_id = $13`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		li.InstallmentID, li.Fees, li.Interest, li.IsPaymentHoliday, li.PayTime, li.Order, li.ParentAccountID, li.Penalty, li.Principal, li.DueTime, li.RepayTime, li.State, li.InstallmentID,
	)
	return err
}

func (repo *Repository) DeleteLoanInstallmentByInstallmentID(ctx context.Context, installmentID string) error {
	const stmt = `DELETE FROM loan_installments
	WHERE installment_id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		installmentID,
	)
	return err
}
