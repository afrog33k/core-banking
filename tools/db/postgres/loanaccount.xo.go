// Package postgres contains generated code from xo.
package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"

	"bnk.to/core/tools/db"
)

func (repo *Repository) InsertLoanAccount(ctx context.Context, la *db.LoanAccount) error {
	const stmt = `INSERT INTO loan_accounts
		(account_id, name, holder_id, holder_type, state, sub_state, accrued_interest, accrued_penalty, activation_transaction_id, arrears_tolerance_period, assets, guarantors, assigned_branch_id, assigned_centre_id, assigned_user_id, balances, revolving_account_id, currency_code, days_in_arrears, days_late, disbursement_details, future_payments_acceptance, interest_commission, interest_from_arrears_accrued, late_payments_recalculation_method, amount, locked_operations, migration_event_id, notes, original_account_id, payment_holidays_accrued_interest, payment_method, product_id, rescheduled_account_id, settings, settlement_account_id, tax_rate, tranches, approve_time, close_time, create_time, appraise_time, interest_apply_time, interest_review_time, lock_time, update_time, arrears_set_time, tax_rate_review_time, terminate_time)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49)
		RETURNING id`
	var id int
	row := repo.db.QueryRowContext(
		ctx, stmt,
		la.AccountID, la.Name, la.HolderID, la.HolderType, la.State, la.SubState, la.AccruedInterest, la.AccruedPenalty, la.ActivationTransactionID, la.ArrearsTolerancePeriod, la.Assets, la.Guarantors, la.AssignedBranchID, la.AssignedCentreID, la.AssignedUserID, la.Balances, la.RevolvingAccountID, la.CurrencyCode, la.DaysInArrears, la.DaysLate, la.DisbursementDetails, la.FuturePaymentsAcceptance, la.InterestCommission, la.InterestFromArrearsAccrued, la.LatePaymentsRecalculationMethod, la.Amount, la.LockedOperations, la.MigrationEventID, la.Notes, la.OriginalAccountID, la.PaymentHolidaysAccruedInterest, la.PaymentMethod, la.ProductID, la.RescheduledAccountID, la.Settings, la.SettlementAccountID, la.TaxRate, la.Tranches, la.ApproveTime, la.CloseTime, la.CreateTime, la.AppraiseTime, la.InterestApplyTime, la.InterestReviewTime, la.LockTime, la.UpdateTime, la.ArrearsSetTime, la.TaxRateReviewTime, la.TerminateTime,
	)
	if err := row.Scan(&id); err != nil {
		return err
	}
	return nil
}

func (repo *Repository) ListLoanAccounts(ctx context.Context, filter string, pageSize int32, orderBy string, after *db.ListPosition) (db.ListStat, []*db.LoanAccount, *db.ListPosition, error) {
	if filter != "" {
		return db.ListStat{}, nil, nil, fmt.Errorf("filter is unimplemented")
	}
	if orderBy == "" {
		orderBy = "id"
	}
	whereClause := `
		(
			(all_entries.ordered_idx > $2) OR
			(all_entries.ordered_idx = $2 AND all_entries.id > $3)
		)
	`
	if after == nil {
		// Use placeholder values but always evaluate to true.
		whereClause = "$2::INTEGER = $3"
		after = &db.ListPosition{
			Data: 0,
			ID:   0,
		}
	}
	const stmt = `WITH all_entries AS (
			SELECT
				quote_ident($1) AS ordered_idx, loan_accounts.id,

				loan_accounts.account_id,
				loan_accounts.name,
				loan_accounts.holder_id,
				loan_accounts.holder_type,
				loan_accounts.state,
				loan_accounts.sub_state,
				loan_accounts.accrued_interest,
				loan_accounts.accrued_penalty,
				loan_accounts.activation_transaction_id,
				loan_accounts.arrears_tolerance_period,
				loan_accounts.assets,
				loan_accounts.guarantors,
				loan_accounts.assigned_branch_id,
				loan_accounts.assigned_centre_id,
				loan_accounts.assigned_user_id,
				loan_accounts.balances,
				loan_accounts.revolving_account_id,
				loan_accounts.currency_code,
				loan_accounts.days_in_arrears,
				loan_accounts.days_late,
				loan_accounts.disbursement_details,
				loan_accounts.future_payments_acceptance,
				loan_accounts.interest_commission,
				loan_accounts.interest_from_arrears_accrued,
				loan_accounts.late_payments_recalculation_method,
				loan_accounts.amount,
				loan_accounts.locked_operations,
				loan_accounts.migration_event_id,
				loan_accounts.notes,
				loan_accounts.original_account_id,
				loan_accounts.payment_holidays_accrued_interest,
				loan_accounts.payment_method,
				loan_accounts.product_id,
				loan_accounts.rescheduled_account_id,
				loan_accounts.settings,
				loan_accounts.settlement_account_id,
				loan_accounts.tax_rate,
				loan_accounts.tranches,
				loan_accounts.approve_time,
				loan_accounts.close_time,
				loan_accounts.create_time,
				loan_accounts.appraise_time,
				loan_accounts.interest_apply_time,
				loan_accounts.interest_review_time,
				loan_accounts.lock_time,
				loan_accounts.update_time,
				loan_accounts.arrears_set_time,
				loan_accounts.tax_rate_review_time,
				loan_accounts.terminate_time
			FROM
				loan_accounts
			WHERE
				%s
		), all_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				all_entries
		), filtered AS (
			SELECT
				*
			FROM
				all_entries
			WHERE %s
		), filtered_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				filtered
		)
		SELECT
			all_count.count, filtered_count.count,
			NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
		FROM
			all_count
			CROSS JOIN filtered_count
		UNION ALL
		(
			SELECT
				*
			FROM
				all_count
				CROSS JOIN filtered_count
				CROSS JOIN filtered
			ORDER BY
				quote_ident($1), filtered.id
			LIMIT
				$4
		)`

	filterSQL := "TRUE" // TODO
	query := fmt.Sprintf(stmt, filterSQL, whereClause)
	rows, err := repo.db.QueryContext(ctx, query, "loan_accounts."+orderBy, after.Data, after.ID, pageSize)
	if err != nil {
		return db.ListStat{}, nil, nil, err
	}

	defer rows.Close()
	result := make([]*db.LoanAccount, 0, pageSize)
	var nextPos db.ListPosition
	var listStat db.ListStat
	if !rows.Next() {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	var x any
	if err := rows.Scan(
		&listStat.Total, &listStat.Remaining,
		&x, &x,
		&x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x,
	); err != nil {
		return db.ListStat{}, nil, nil, err
	}
	for rows.Next() {
		var next db.LoanAccount
		if err := rows.Scan(
			&listStat.Total, &listStat.Remaining,
			&nextPos.Data, &nextPos.ID,
			&next.AccountID, &next.Name, &next.HolderID, &next.HolderType, &next.State, &next.SubState, &next.AccruedInterest, &next.AccruedPenalty, &next.ActivationTransactionID, &next.ArrearsTolerancePeriod, &next.Assets, &next.Guarantors, &next.AssignedBranchID, &next.AssignedCentreID, &next.AssignedUserID, &next.Balances, &next.RevolvingAccountID, &next.CurrencyCode, &next.DaysInArrears, &next.DaysLate, &next.DisbursementDetails, &next.FuturePaymentsAcceptance, &next.InterestCommission, &next.InterestFromArrearsAccrued, &next.LatePaymentsRecalculationMethod, &next.Amount, &next.LockedOperations, &next.MigrationEventID, &next.Notes, &next.OriginalAccountID, &next.PaymentHolidaysAccruedInterest, &next.PaymentMethod, &next.ProductID, &next.RescheduledAccountID, &next.Settings, &next.SettlementAccountID, &next.TaxRate, &next.Tranches, &next.ApproveTime, &next.CloseTime, &next.CreateTime, &next.AppraiseTime, &next.InterestApplyTime, &next.InterestReviewTime, &next.LockTime, &next.UpdateTime, &next.ArrearsSetTime, &next.TaxRateReviewTime, &next.TerminateTime,
		); err != nil {
			return db.ListStat{}, nil, nil, err
		}
		result = append(result, &next)
	}
	if rows.Err() != nil {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	return listStat, result, &nextPos, nil
}

func (repo *Repository) LoanAccountByID(ctx context.Context, id int32) (*db.LoanAccount, error) {
	const stmt = `SELECT
		loan_accounts.id,

		loan_accounts.account_id,
		loan_accounts.name,
		loan_accounts.holder_id,
		loan_accounts.holder_type,
		loan_accounts.state,
		loan_accounts.sub_state,
		loan_accounts.accrued_interest,
		loan_accounts.accrued_penalty,
		loan_accounts.activation_transaction_id,
		loan_accounts.arrears_tolerance_period,
		loan_accounts.assets,
		loan_accounts.guarantors,
		loan_accounts.assigned_branch_id,
		loan_accounts.assigned_centre_id,
		loan_accounts.assigned_user_id,
		loan_accounts.balances,
		loan_accounts.revolving_account_id,
		loan_accounts.currency_code,
		loan_accounts.days_in_arrears,
		loan_accounts.days_late,
		loan_accounts.disbursement_details,
		loan_accounts.future_payments_acceptance,
		loan_accounts.interest_commission,
		loan_accounts.interest_from_arrears_accrued,
		loan_accounts.late_payments_recalculation_method,
		loan_accounts.amount,
		loan_accounts.locked_operations,
		loan_accounts.migration_event_id,
		loan_accounts.notes,
		loan_accounts.original_account_id,
		loan_accounts.payment_holidays_accrued_interest,
		loan_accounts.payment_method,
		loan_accounts.product_id,
		loan_accounts.rescheduled_account_id,
		loan_accounts.settings,
		loan_accounts.settlement_account_id,
		loan_accounts.tax_rate,
		loan_accounts.tranches,
		loan_accounts.approve_time,
		loan_accounts.close_time,
		loan_accounts.create_time,
		loan_accounts.appraise_time,
		loan_accounts.interest_apply_time,
		loan_accounts.interest_review_time,
		loan_accounts.lock_time,
		loan_accounts.update_time,
		loan_accounts.arrears_set_time,
		loan_accounts.tax_rate_review_time,
		loan_accounts.terminate_time
	FROM
		loan_accounts
	WHERE
		id = $1`

	var la db.LoanAccount
	row := repo.db.QueryRowContext(ctx, stmt, id)
	if err := row.Scan(
		&la.ID,
		&la.AccountID, &la.Name, &la.HolderID, &la.HolderType, &la.State, &la.SubState, &la.AccruedInterest, &la.AccruedPenalty, &la.ActivationTransactionID, &la.ArrearsTolerancePeriod, &la.Assets, &la.Guarantors, &la.AssignedBranchID, &la.AssignedCentreID, &la.AssignedUserID, &la.Balances, &la.RevolvingAccountID, &la.CurrencyCode, &la.DaysInArrears, &la.DaysLate, &la.DisbursementDetails, &la.FuturePaymentsAcceptance, &la.InterestCommission, &la.InterestFromArrearsAccrued, &la.LatePaymentsRecalculationMethod, &la.Amount, &la.LockedOperations, &la.MigrationEventID, &la.Notes, &la.OriginalAccountID, &la.PaymentHolidaysAccruedInterest, &la.PaymentMethod, &la.ProductID, &la.RescheduledAccountID, &la.Settings, &la.SettlementAccountID, &la.TaxRate, &la.Tranches, &la.ApproveTime, &la.CloseTime, &la.CreateTime, &la.AppraiseTime, &la.InterestApplyTime, &la.InterestReviewTime, &la.LockTime, &la.UpdateTime, &la.ArrearsSetTime, &la.TaxRateReviewTime, &la.TerminateTime,
	); err != nil {
		return nil, err
	}

	return &la, nil
}

func (repo *Repository) UpdateLoanAccountByID(ctx context.Context, la *db.LoanAccount) error {
	const stmt = `UPDATE loan_accounts
	SET account_id=$1,
		name=$2,
		holder_id=$3,
		holder_type=$4,
		state=$5,
		sub_state=$6,
		accrued_interest=$7,
		accrued_penalty=$8,
		activation_transaction_id=$9,
		arrears_tolerance_period=$10,
		assets=$11,
		guarantors=$12,
		assigned_branch_id=$13,
		assigned_centre_id=$14,
		assigned_user_id=$15,
		balances=$16,
		revolving_account_id=$17,
		currency_code=$18,
		days_in_arrears=$19,
		days_late=$20,
		disbursement_details=$21,
		future_payments_acceptance=$22,
		interest_commission=$23,
		interest_from_arrears_accrued=$24,
		late_payments_recalculation_method=$25,
		amount=$26,
		locked_operations=$27,
		migration_event_id=$28,
		notes=$29,
		original_account_id=$30,
		payment_holidays_accrued_interest=$31,
		payment_method=$32,
		product_id=$33,
		rescheduled_account_id=$34,
		settings=$35,
		settlement_account_id=$36,
		tax_rate=$37,
		tranches=$38,
		approve_time=$39,
		close_time=$40,
		appraise_time=$41,
		interest_apply_time=$42,
		interest_review_time=$43,
		lock_time=$44,
		update_time=$45,
		arrears_set_time=$46,
		tax_rate_review_time=$47,
		terminate_time=$48
	WHERE id = $49`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		la.AccountID, la.Name, la.HolderID, la.HolderType, la.State, la.SubState, la.AccruedInterest, la.AccruedPenalty, la.ActivationTransactionID, la.ArrearsTolerancePeriod, la.Assets, la.Guarantors, la.AssignedBranchID, la.AssignedCentreID, la.AssignedUserID, la.Balances, la.RevolvingAccountID, la.CurrencyCode, la.DaysInArrears, la.DaysLate, la.DisbursementDetails, la.FuturePaymentsAcceptance, la.InterestCommission, la.InterestFromArrearsAccrued, la.LatePaymentsRecalculationMethod, la.Amount, la.LockedOperations, la.MigrationEventID, la.Notes, la.OriginalAccountID, la.PaymentHolidaysAccruedInterest, la.PaymentMethod, la.ProductID, la.RescheduledAccountID, la.Settings, la.SettlementAccountID, la.TaxRate, la.Tranches, la.ApproveTime, la.CloseTime, la.AppraiseTime, la.InterestApplyTime, la.InterestReviewTime, la.LockTime, la.UpdateTime, la.ArrearsSetTime, la.TaxRateReviewTime, la.TerminateTime, la.ID,
	)
	return err
}

func (repo *Repository) DeleteLoanAccountByID(ctx context.Context, id int32) error {
	const stmt = `DELETE FROM loan_accounts
	WHERE id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		id,
	)
	return err
}

func (repo *Repository) LoanAccountByAccountID(ctx context.Context, accountID string) (*db.LoanAccount, error) {
	const stmt = `SELECT
		loan_accounts.id,

		loan_accounts.account_id,
		loan_accounts.name,
		loan_accounts.holder_id,
		loan_accounts.holder_type,
		loan_accounts.state,
		loan_accounts.sub_state,
		loan_accounts.accrued_interest,
		loan_accounts.accrued_penalty,
		loan_accounts.activation_transaction_id,
		loan_accounts.arrears_tolerance_period,
		loan_accounts.assets,
		loan_accounts.guarantors,
		loan_accounts.assigned_branch_id,
		loan_accounts.assigned_centre_id,
		loan_accounts.assigned_user_id,
		loan_accounts.balances,
		loan_accounts.revolving_account_id,
		loan_accounts.currency_code,
		loan_accounts.days_in_arrears,
		loan_accounts.days_late,
		loan_accounts.disbursement_details,
		loan_accounts.future_payments_acceptance,
		loan_accounts.interest_commission,
		loan_accounts.interest_from_arrears_accrued,
		loan_accounts.late_payments_recalculation_method,
		loan_accounts.amount,
		loan_accounts.locked_operations,
		loan_accounts.migration_event_id,
		loan_accounts.notes,
		loan_accounts.original_account_id,
		loan_accounts.payment_holidays_accrued_interest,
		loan_accounts.payment_method,
		loan_accounts.product_id,
		loan_accounts.rescheduled_account_id,
		loan_accounts.settings,
		loan_accounts.settlement_account_id,
		loan_accounts.tax_rate,
		loan_accounts.tranches,
		loan_accounts.approve_time,
		loan_accounts.close_time,
		loan_accounts.create_time,
		loan_accounts.appraise_time,
		loan_accounts.interest_apply_time,
		loan_accounts.interest_review_time,
		loan_accounts.lock_time,
		loan_accounts.update_time,
		loan_accounts.arrears_set_time,
		loan_accounts.tax_rate_review_time,
		loan_accounts.terminate_time
	FROM
		loan_accounts
	WHERE
		account_id = $1`

	var la db.LoanAccount
	row := repo.db.QueryRowContext(ctx, stmt, accountID)
	if err := row.Scan(
		&la.ID,
		&la.AccountID, &la.Name, &la.HolderID, &la.HolderType, &la.State, &la.SubState, &la.AccruedInterest, &la.AccruedPenalty, &la.ActivationTransactionID, &la.ArrearsTolerancePeriod, &la.Assets, &la.Guarantors, &la.AssignedBranchID, &la.AssignedCentreID, &la.AssignedUserID, &la.Balances, &la.RevolvingAccountID, &la.CurrencyCode, &la.DaysInArrears, &la.DaysLate, &la.DisbursementDetails, &la.FuturePaymentsAcceptance, &la.InterestCommission, &la.InterestFromArrearsAccrued, &la.LatePaymentsRecalculationMethod, &la.Amount, &la.LockedOperations, &la.MigrationEventID, &la.Notes, &la.OriginalAccountID, &la.PaymentHolidaysAccruedInterest, &la.PaymentMethod, &la.ProductID, &la.RescheduledAccountID, &la.Settings, &la.SettlementAccountID, &la.TaxRate, &la.Tranches, &la.ApproveTime, &la.CloseTime, &la.CreateTime, &la.AppraiseTime, &la.InterestApplyTime, &la.InterestReviewTime, &la.LockTime, &la.UpdateTime, &la.ArrearsSetTime, &la.TaxRateReviewTime, &la.TerminateTime,
	); err != nil {
		return nil, err
	}

	return &la, nil
}

func (repo *Repository) UpdateLoanAccountByAccountID(ctx context.Context, la *db.LoanAccount) error {
	const stmt = `UPDATE loan_accounts
	SET account_id=$1,
		name=$2,
		holder_id=$3,
		holder_type=$4,
		state=$5,
		sub_state=$6,
		accrued_interest=$7,
		accrued_penalty=$8,
		activation_transaction_id=$9,
		arrears_tolerance_period=$10,
		assets=$11,
		guarantors=$12,
		assigned_branch_id=$13,
		assigned_centre_id=$14,
		assigned_user_id=$15,
		balances=$16,
		revolving_account_id=$17,
		currency_code=$18,
		days_in_arrears=$19,
		days_late=$20,
		disbursement_details=$21,
		future_payments_acceptance=$22,
		interest_commission=$23,
		interest_from_arrears_accrued=$24,
		late_payments_recalculation_method=$25,
		amount=$26,
		locked_operations=$27,
		migration_event_id=$28,
		notes=$29,
		original_account_id=$30,
		payment_holidays_accrued_interest=$31,
		payment_method=$32,
		product_id=$33,
		rescheduled_account_id=$34,
		settings=$35,
		settlement_account_id=$36,
		tax_rate=$37,
		tranches=$38,
		approve_time=$39,
		close_time=$40,
		appraise_time=$41,
		interest_apply_time=$42,
		interest_review_time=$43,
		lock_time=$44,
		update_time=$45,
		arrears_set_time=$46,
		tax_rate_review_time=$47,
		terminate_time=$48
	WHERE account_id = $49`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		la.AccountID, la.Name, la.HolderID, la.HolderType, la.State, la.SubState, la.AccruedInterest, la.AccruedPenalty, la.ActivationTransactionID, la.ArrearsTolerancePeriod, la.Assets, la.Guarantors, la.AssignedBranchID, la.AssignedCentreID, la.AssignedUserID, la.Balances, la.RevolvingAccountID, la.CurrencyCode, la.DaysInArrears, la.DaysLate, la.DisbursementDetails, la.FuturePaymentsAcceptance, la.InterestCommission, la.InterestFromArrearsAccrued, la.LatePaymentsRecalculationMethod, la.Amount, la.LockedOperations, la.MigrationEventID, la.Notes, la.OriginalAccountID, la.PaymentHolidaysAccruedInterest, la.PaymentMethod, la.ProductID, la.RescheduledAccountID, la.Settings, la.SettlementAccountID, la.TaxRate, la.Tranches, la.ApproveTime, la.CloseTime, la.AppraiseTime, la.InterestApplyTime, la.InterestReviewTime, la.LockTime, la.UpdateTime, la.ArrearsSetTime, la.TaxRateReviewTime, la.TerminateTime, la.AccountID,
	)
	return err
}

func (repo *Repository) DeleteLoanAccountByAccountID(ctx context.Context, accountID string) error {
	const stmt = `DELETE FROM loan_accounts
	WHERE account_id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		accountID,
	)
	return err
}
