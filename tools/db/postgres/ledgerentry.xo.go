// Package postgres contains generated code from xo.
package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"

	"bnk.to/core/tools/db"
)

func (repo *Repository) InsertLedgerEntry(ctx context.Context, le *db.LedgerEntry) error {
	const stmt = `WITH ledger_entries_accounting_rate AS (
		INSERT INTO currency_accounting_rates
			(rate_id, rate, from_currency, to_currency, start_time, end_time)
			VALUES ($1, $2, $3, $4, $5, $6)
			RETURNING id
	)
	INSERT INTO ledger_entries
		(entry_id, account_id, branch_id, user_id, transaction_id, type, product_id, product_type, amount, accounting_rate, notes, reversal_entry_id, create_time, book_time)
		SELECT $7, $8, $9, $10, $11, $12, $13, $14, $15, ledger_entries_accounting_rate.id, $16, $17, $18, $19
		FROM ledger_entries_accounting_rate
		RETURNING id`
	var id int
	row := repo.db.QueryRowContext(
		ctx, stmt,
		le.AccountingRate.RateID, le.AccountingRate.Rate, le.AccountingRate.FromCurrency, le.AccountingRate.ToCurrency, le.AccountingRate.StartTime, le.AccountingRate.EndTime,
		le.EntryID, le.AccountID, le.BranchID, le.UserID, le.TransactionID, le.Type, le.ProductID, le.ProductType, le.Amount, le.Notes, le.ReversalEntryID, le.CreateTime, le.BookTime,
	)
	if err := row.Scan(&id); err != nil {
		return err
	}
	return nil
}

func (repo *Repository) ListLedgerEntries(ctx context.Context, filter string, pageSize int32, orderBy string, after *db.ListPosition) (db.ListStat, []*db.LedgerEntry, *db.ListPosition, error) {
	if filter != "" {
		return db.ListStat{}, nil, nil, fmt.Errorf("filter is unimplemented")
	}
	if orderBy == "" {
		orderBy = "id"
	}
	whereClause := `
		(
			(all_entries.ordered_idx > $2) OR
			(all_entries.ordered_idx = $2 AND all_entries.id > $3)
		)
	`
	if after == nil {
		// Use placeholder values but always evaluate to true.
		whereClause = "$2::INTEGER = $3"
		after = &db.ListPosition{
			Data: 0,
			ID:   0,
		}
	}
	const stmt = `WITH all_entries AS (
			SELECT
				quote_ident($1) AS ordered_idx, ledger_entries.id,

				ledger_entries_accounting_rate_tbl.rate_id,
				ledger_entries_accounting_rate_tbl.rate,
				ledger_entries_accounting_rate_tbl.from_currency,
				ledger_entries_accounting_rate_tbl.to_currency,
				ledger_entries_accounting_rate_tbl.start_time,
				ledger_entries_accounting_rate_tbl.end_time,

				ledger_entries.entry_id,
				ledger_entries.account_id,
				ledger_entries.branch_id,
				ledger_entries.user_id,
				ledger_entries.transaction_id,
				ledger_entries.type,
				ledger_entries.product_id,
				ledger_entries.product_type,
				ledger_entries.amount,
				ledger_entries.notes,
				ledger_entries.reversal_entry_id,
				ledger_entries.create_time,
				ledger_entries.book_time
			FROM
				ledger_entries
				JOIN currency_accounting_rates AS ledger_entries_accounting_rate_tbl ON ledger_entries_accounting_rate_tbl.id = ledger_entries.accounting_rate
			WHERE
				%s
		), all_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				all_entries
		), filtered AS (
			SELECT
				*
			FROM
				all_entries
			WHERE %s
		), filtered_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				filtered
		)
		SELECT
			all_count.count, filtered_count.count,
			NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
		FROM
			all_count
			CROSS JOIN filtered_count
		UNION ALL
		(
			SELECT
				*
			FROM
				all_count
				CROSS JOIN filtered_count
				CROSS JOIN filtered
			ORDER BY
				quote_ident($1), filtered.id
			LIMIT
				$4
		)`

	filterSQL := "TRUE" // TODO
	query := fmt.Sprintf(stmt, filterSQL, whereClause)
	rows, err := repo.db.QueryContext(ctx, query, "ledger_entries."+orderBy, after.Data, after.ID, pageSize)
	if err != nil {
		return db.ListStat{}, nil, nil, err
	}

	defer rows.Close()
	result := make([]*db.LedgerEntry, 0, pageSize)
	var nextPos db.ListPosition
	var listStat db.ListStat
	if !rows.Next() {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	var x any
	if err := rows.Scan(
		&listStat.Total, &listStat.Remaining,
		&x, &x,
		&x, &x, &x, &x, &x, &x,
		&x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x,
	); err != nil {
		return db.ListStat{}, nil, nil, err
	}
	for rows.Next() {
		var next db.LedgerEntry
		if err := rows.Scan(
			&listStat.Total, &listStat.Remaining,
			&nextPos.Data, &nextPos.ID,
			&next.AccountingRate.RateID, &next.AccountingRate.Rate, &next.AccountingRate.FromCurrency, &next.AccountingRate.ToCurrency, &next.AccountingRate.StartTime, &next.AccountingRate.EndTime,
			&next.EntryID, &next.AccountID, &next.BranchID, &next.UserID, &next.TransactionID, &next.Type, &next.ProductID, &next.ProductType, &next.Amount, &next.Notes, &next.ReversalEntryID, &next.CreateTime, &next.BookTime,
		); err != nil {
			return db.ListStat{}, nil, nil, err
		}
		result = append(result, &next)
	}
	if rows.Err() != nil {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	return listStat, result, &nextPos, nil
}

func (repo *Repository) LedgerEntryByID(ctx context.Context, id int32) (*db.LedgerEntry, error) {
	const stmt = `SELECT
		ledger_entries.id,

		ledger_entries_accounting_rate_tbl.rate_id,
		ledger_entries_accounting_rate_tbl.rate,
		ledger_entries_accounting_rate_tbl.from_currency,
		ledger_entries_accounting_rate_tbl.to_currency,
		ledger_entries_accounting_rate_tbl.start_time,
		ledger_entries_accounting_rate_tbl.end_time,

		ledger_entries.entry_id,
		ledger_entries.account_id,
		ledger_entries.branch_id,
		ledger_entries.user_id,
		ledger_entries.transaction_id,
		ledger_entries.type,
		ledger_entries.product_id,
		ledger_entries.product_type,
		ledger_entries.amount,
		ledger_entries.notes,
		ledger_entries.reversal_entry_id,
		ledger_entries.create_time,
		ledger_entries.book_time
	FROM
		ledger_entries
		JOIN currency_accounting_rates AS ledger_entries_accounting_rate_tbl ON ledger_entries_accounting_rate_tbl.id = ledger_entries.accounting_rate
	WHERE
		id = $1`

	var le db.LedgerEntry
	row := repo.db.QueryRowContext(ctx, stmt, id)
	if err := row.Scan(
		&le.ID,
		&le.AccountingRate.RateID, &le.AccountingRate.Rate, &le.AccountingRate.FromCurrency, &le.AccountingRate.ToCurrency, &le.AccountingRate.StartTime, &le.AccountingRate.EndTime,
		&le.EntryID, &le.AccountID, &le.BranchID, &le.UserID, &le.TransactionID, &le.Type, &le.ProductID, &le.ProductType, &le.Amount, &le.Notes, &le.ReversalEntryID, &le.CreateTime, &le.BookTime,
	); err != nil {
		return nil, err
	}

	return &le, nil
}

func (repo *Repository) UpdateLedgerEntryByID(ctx context.Context, le *db.LedgerEntry) error {
	const stmt = `WITH ledger_entries_currency_accounting_rates AS (
		UPDATE currency_accounting_rates
		SET rate_id=$1,
			rate=$2,
			from_currency=$3,
			to_currency=$4,
			start_time=$5,
			end_time=$6
		FROM ledger_entries
		WHERE ledger_entries.accounting_rate = currency_accounting_rates.id AND
			ledger_entries.id = $7
	)
	UPDATE ledger_entries
	SET entry_id=$8,
		account_id=$9,
		branch_id=$10,
		user_id=$11,
		transaction_id=$12,
		type=$13,
		product_id=$14,
		product_type=$15,
		amount=$16,
		notes=$17,
		reversal_entry_id=$18,
		book_time=$19
	WHERE id = $20`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		le.AccountingRate.RateID, le.AccountingRate.Rate, le.AccountingRate.FromCurrency, le.AccountingRate.ToCurrency, le.AccountingRate.StartTime, le.AccountingRate.EndTime, le.ID,
		le.EntryID, le.AccountID, le.BranchID, le.UserID, le.TransactionID, le.Type, le.ProductID, le.ProductType, le.Amount, le.Notes, le.ReversalEntryID, le.BookTime, le.ID,
	)
	return err
}

func (repo *Repository) DeleteLedgerEntryByID(ctx context.Context, id int32) error {
	const stmt = `WITH ledger_entries_currency_accounting_rates AS (
		DELETE FROM currency_accounting_rates
		USING ledger_entries
		WHERE ledger_entries.accounting_rate = currency_accounting_rates.id AND
			ledger_entries.id = $1
	)
	DELETE FROM ledger_entries
	WHERE id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		id,
	)
	return err
}

func (repo *Repository) LedgerEntryByEntryID(ctx context.Context, entryID string) (*db.LedgerEntry, error) {
	const stmt = `SELECT
		ledger_entries.id,

		ledger_entries_accounting_rate_tbl.rate_id,
		ledger_entries_accounting_rate_tbl.rate,
		ledger_entries_accounting_rate_tbl.from_currency,
		ledger_entries_accounting_rate_tbl.to_currency,
		ledger_entries_accounting_rate_tbl.start_time,
		ledger_entries_accounting_rate_tbl.end_time,

		ledger_entries.entry_id,
		ledger_entries.account_id,
		ledger_entries.branch_id,
		ledger_entries.user_id,
		ledger_entries.transaction_id,
		ledger_entries.type,
		ledger_entries.product_id,
		ledger_entries.product_type,
		ledger_entries.amount,
		ledger_entries.notes,
		ledger_entries.reversal_entry_id,
		ledger_entries.create_time,
		ledger_entries.book_time
	FROM
		ledger_entries
		JOIN currency_accounting_rates AS ledger_entries_accounting_rate_tbl ON ledger_entries_accounting_rate_tbl.id = ledger_entries.accounting_rate
	WHERE
		entry_id = $1`

	var le db.LedgerEntry
	row := repo.db.QueryRowContext(ctx, stmt, entryID)
	if err := row.Scan(
		&le.ID,
		&le.AccountingRate.RateID, &le.AccountingRate.Rate, &le.AccountingRate.FromCurrency, &le.AccountingRate.ToCurrency, &le.AccountingRate.StartTime, &le.AccountingRate.EndTime,
		&le.EntryID, &le.AccountID, &le.BranchID, &le.UserID, &le.TransactionID, &le.Type, &le.ProductID, &le.ProductType, &le.Amount, &le.Notes, &le.ReversalEntryID, &le.CreateTime, &le.BookTime,
	); err != nil {
		return nil, err
	}

	return &le, nil
}

func (repo *Repository) UpdateLedgerEntryByEntryID(ctx context.Context, le *db.LedgerEntry) error {
	const stmt = `WITH ledger_entries_currency_accounting_rates AS (
		UPDATE currency_accounting_rates
		SET rate_id=$1,
			rate=$2,
			from_currency=$3,
			to_currency=$4,
			start_time=$5,
			end_time=$6
		FROM ledger_entries
		WHERE ledger_entries.accounting_rate = currency_accounting_rates.id AND
			ledger_entries.entry_id = $7
	)
	UPDATE ledger_entries
	SET entry_id=$8,
		account_id=$9,
		branch_id=$10,
		user_id=$11,
		transaction_id=$12,
		type=$13,
		product_id=$14,
		product_type=$15,
		amount=$16,
		notes=$17,
		reversal_entry_id=$18,
		book_time=$19
	WHERE entry_id = $20`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		le.AccountingRate.RateID, le.AccountingRate.Rate, le.AccountingRate.FromCurrency, le.AccountingRate.ToCurrency, le.AccountingRate.StartTime, le.AccountingRate.EndTime, le.EntryID,
		le.EntryID, le.AccountID, le.BranchID, le.UserID, le.TransactionID, le.Type, le.ProductID, le.ProductType, le.Amount, le.Notes, le.ReversalEntryID, le.BookTime, le.EntryID,
	)
	return err
}

func (repo *Repository) DeleteLedgerEntryByEntryID(ctx context.Context, entryID string) error {
	const stmt = `WITH ledger_entries_currency_accounting_rates AS (
		DELETE FROM currency_accounting_rates
		USING ledger_entries
		WHERE ledger_entries.accounting_rate = currency_accounting_rates.id AND
			ledger_entries.entry_id = $1
	)
	DELETE FROM ledger_entries
	WHERE entry_id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		entryID,
	)
	return err
}
