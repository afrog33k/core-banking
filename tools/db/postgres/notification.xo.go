// Package postgres contains generated code from xo.
package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"

	"bnk.to/core/tools/db"
)

func (repo *Repository) InsertNotification(ctx context.Context, n *db.Notification) error {
	const stmt = `INSERT INTO notifications
		(notification_id, user_id, client_id, group_id, deposit_account_id, loan_account_id, repayment_id, type, event, status, template_id, destination, sender_id, subject, body, num_retries, create_time, send_time, failure_reason, failure_cause)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
		RETURNING id`
	var id int
	row := repo.db.QueryRowContext(
		ctx, stmt,
		n.NotificationID, n.UserID, n.ClientID, n.GroupID, n.DepositAccountID, n.LoanAccountID, n.RepaymentID, n.Type, n.Event, n.Status, n.TemplateID, n.Destination, n.SenderID, n.Subject, n.Body, n.NumRetries, n.CreateTime, n.SendTime, n.FailureReason, n.FailureCause,
	)
	if err := row.Scan(&id); err != nil {
		return err
	}
	return nil
}

func (repo *Repository) ListNotifications(ctx context.Context, filter string, pageSize int32, orderBy string, after *db.ListPosition) (db.ListStat, []*db.Notification, *db.ListPosition, error) {
	if filter != "" {
		return db.ListStat{}, nil, nil, fmt.Errorf("filter is unimplemented")
	}
	if orderBy == "" {
		orderBy = "id"
	}
	whereClause := `
		(
			(all_entries.ordered_idx > $2) OR
			(all_entries.ordered_idx = $2 AND all_entries.id > $3)
		)
	`
	if after == nil {
		// Use placeholder values but always evaluate to true.
		whereClause = "$2::INTEGER = $3"
		after = &db.ListPosition{
			Data: 0,
			ID:   0,
		}
	}
	const stmt = `WITH all_entries AS (
			SELECT
				quote_ident($1) AS ordered_idx, notifications.id,

				notifications.notification_id,
				notifications.user_id,
				notifications.client_id,
				notifications.group_id,
				notifications.deposit_account_id,
				notifications.loan_account_id,
				notifications.repayment_id,
				notifications.type,
				notifications.event,
				notifications.status,
				notifications.template_id,
				notifications.destination,
				notifications.sender_id,
				notifications.subject,
				notifications.body,
				notifications.num_retries,
				notifications.create_time,
				notifications.send_time,
				notifications.failure_reason,
				notifications.failure_cause
			FROM
				notifications
			WHERE
				%s
		), all_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				all_entries
		), filtered AS (
			SELECT
				*
			FROM
				all_entries
			WHERE %s
		), filtered_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				filtered
		)
		SELECT
			all_count.count, filtered_count.count,
			NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
		FROM
			all_count
			CROSS JOIN filtered_count
		UNION ALL
		(
			SELECT
				*
			FROM
				all_count
				CROSS JOIN filtered_count
				CROSS JOIN filtered
			ORDER BY
				quote_ident($1), filtered.id
			LIMIT
				$4
		)`

	filterSQL := "TRUE" // TODO
	query := fmt.Sprintf(stmt, filterSQL, whereClause)
	rows, err := repo.db.QueryContext(ctx, query, "notifications."+orderBy, after.Data, after.ID, pageSize)
	if err != nil {
		return db.ListStat{}, nil, nil, err
	}

	defer rows.Close()
	result := make([]*db.Notification, 0, pageSize)
	var nextPos db.ListPosition
	var listStat db.ListStat
	if !rows.Next() {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	var x any
	if err := rows.Scan(
		&listStat.Total, &listStat.Remaining,
		&x, &x,
		&x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x,
	); err != nil {
		return db.ListStat{}, nil, nil, err
	}
	for rows.Next() {
		var next db.Notification
		if err := rows.Scan(
			&listStat.Total, &listStat.Remaining,
			&nextPos.Data, &nextPos.ID,
			&next.NotificationID, &next.UserID, &next.ClientID, &next.GroupID, &next.DepositAccountID, &next.LoanAccountID, &next.RepaymentID, &next.Type, &next.Event, &next.Status, &next.TemplateID, &next.Destination, &next.SenderID, &next.Subject, &next.Body, &next.NumRetries, &next.CreateTime, &next.SendTime, &next.FailureReason, &next.FailureCause,
		); err != nil {
			return db.ListStat{}, nil, nil, err
		}
		result = append(result, &next)
	}
	if rows.Err() != nil {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	return listStat, result, &nextPos, nil
}

func (repo *Repository) NotificationByID(ctx context.Context, id int32) (*db.Notification, error) {
	const stmt = `SELECT
		notifications.id,

		notifications.notification_id,
		notifications.user_id,
		notifications.client_id,
		notifications.group_id,
		notifications.deposit_account_id,
		notifications.loan_account_id,
		notifications.repayment_id,
		notifications.type,
		notifications.event,
		notifications.status,
		notifications.template_id,
		notifications.destination,
		notifications.sender_id,
		notifications.subject,
		notifications.body,
		notifications.num_retries,
		notifications.create_time,
		notifications.send_time,
		notifications.failure_reason,
		notifications.failure_cause
	FROM
		notifications
	WHERE
		id = $1`

	var n db.Notification
	row := repo.db.QueryRowContext(ctx, stmt, id)
	if err := row.Scan(
		&n.ID,
		&n.NotificationID, &n.UserID, &n.ClientID, &n.GroupID, &n.DepositAccountID, &n.LoanAccountID, &n.RepaymentID, &n.Type, &n.Event, &n.Status, &n.TemplateID, &n.Destination, &n.SenderID, &n.Subject, &n.Body, &n.NumRetries, &n.CreateTime, &n.SendTime, &n.FailureReason, &n.FailureCause,
	); err != nil {
		return nil, err
	}

	return &n, nil
}

func (repo *Repository) UpdateNotificationByID(ctx context.Context, n *db.Notification) error {
	const stmt = `UPDATE notifications
	SET notification_id=$1,
		user_id=$2,
		client_id=$3,
		group_id=$4,
		deposit_account_id=$5,
		loan_account_id=$6,
		repayment_id=$7,
		type=$8,
		event=$9,
		status=$10,
		template_id=$11,
		destination=$12,
		sender_id=$13,
		subject=$14,
		body=$15,
		num_retries=$16,
		send_time=$17,
		failure_reason=$18,
		failure_cause=$19
	WHERE id = $20`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		n.NotificationID, n.UserID, n.ClientID, n.GroupID, n.DepositAccountID, n.LoanAccountID, n.RepaymentID, n.Type, n.Event, n.Status, n.TemplateID, n.Destination, n.SenderID, n.Subject, n.Body, n.NumRetries, n.SendTime, n.FailureReason, n.FailureCause, n.ID,
	)
	return err
}

func (repo *Repository) DeleteNotificationByID(ctx context.Context, id int32) error {
	const stmt = `DELETE FROM notifications
	WHERE id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		id,
	)
	return err
}

func (repo *Repository) NotificationByNotificationID(ctx context.Context, notificationID string) (*db.Notification, error) {
	const stmt = `SELECT
		notifications.id,

		notifications.notification_id,
		notifications.user_id,
		notifications.client_id,
		notifications.group_id,
		notifications.deposit_account_id,
		notifications.loan_account_id,
		notifications.repayment_id,
		notifications.type,
		notifications.event,
		notifications.status,
		notifications.template_id,
		notifications.destination,
		notifications.sender_id,
		notifications.subject,
		notifications.body,
		notifications.num_retries,
		notifications.create_time,
		notifications.send_time,
		notifications.failure_reason,
		notifications.failure_cause
	FROM
		notifications
	WHERE
		notification_id = $1`

	var n db.Notification
	row := repo.db.QueryRowContext(ctx, stmt, notificationID)
	if err := row.Scan(
		&n.ID,
		&n.NotificationID, &n.UserID, &n.ClientID, &n.GroupID, &n.DepositAccountID, &n.LoanAccountID, &n.RepaymentID, &n.Type, &n.Event, &n.Status, &n.TemplateID, &n.Destination, &n.SenderID, &n.Subject, &n.Body, &n.NumRetries, &n.CreateTime, &n.SendTime, &n.FailureReason, &n.FailureCause,
	); err != nil {
		return nil, err
	}

	return &n, nil
}

func (repo *Repository) UpdateNotificationByNotificationID(ctx context.Context, n *db.Notification) error {
	const stmt = `UPDATE notifications
	SET notification_id=$1,
		user_id=$2,
		client_id=$3,
		group_id=$4,
		deposit_account_id=$5,
		loan_account_id=$6,
		repayment_id=$7,
		type=$8,
		event=$9,
		status=$10,
		template_id=$11,
		destination=$12,
		sender_id=$13,
		subject=$14,
		body=$15,
		num_retries=$16,
		send_time=$17,
		failure_reason=$18,
		failure_cause=$19
	WHERE notification_id = $20`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		n.NotificationID, n.UserID, n.ClientID, n.GroupID, n.DepositAccountID, n.LoanAccountID, n.RepaymentID, n.Type, n.Event, n.Status, n.TemplateID, n.Destination, n.SenderID, n.Subject, n.Body, n.NumRetries, n.SendTime, n.FailureReason, n.FailureCause, n.NotificationID,
	)
	return err
}

func (repo *Repository) DeleteNotificationByNotificationID(ctx context.Context, notificationID string) error {
	const stmt = `DELETE FROM notifications
	WHERE notification_id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		notificationID,
	)
	return err
}
