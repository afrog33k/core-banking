// Package postgres contains generated code from xo.
package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"fmt"

	"bnk.to/core/tools/db"
)

func (repo *Repository) InsertTransactionDepositTransaction(ctx context.Context, tdt *db.TransactionDepositTransaction) error {
	const stmt = `WITH transaction_deposit_transactions_card_transaction AS (
		INSERT INTO card_transactions
			(transaction_id, advice, amount, acceptor, card_id, authorization_id, transaction_time)
			VALUES ($1, $2, $3, $4, $5, $6, $7)
			RETURNING id
	)
	INSERT INTO transaction_deposit_transactions
		(transaction_id, user_id, total_change, affected_amounts, adjustment_transaction_id, block_id, branch_id, centre_id, card_transaction, parent_account_id, fees, interest_accrued_amounts, migration_event_id, notes, original_transaction_id, payment, order_id, tax_rate, terms, till_id, channel_id, transfer_details, type, create_time, book_time, value_time)
		SELECT $8, $9, $10, $11, $12, $13, $14, $15, transaction_deposit_transactions_card_transaction.id, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32
		FROM transaction_deposit_transactions_card_transaction
		RETURNING id`
	var id int
	row := repo.db.QueryRowContext(
		ctx, stmt,
		tdt.CardTransaction.TransactionID, tdt.CardTransaction.Advice, tdt.CardTransaction.Amount, tdt.CardTransaction.Acceptor, tdt.CardTransaction.CardID, tdt.CardTransaction.AuthorizationID, tdt.CardTransaction.TransactionTime,
		tdt.TransactionID, tdt.UserID, tdt.TotalChange, tdt.AffectedAmounts, tdt.AdjustmentTransactionID, tdt.BlockID, tdt.BranchID, tdt.CentreID, tdt.ParentAccountID, tdt.Fees, tdt.InterestAccruedAmounts, tdt.MigrationEventID, tdt.Notes, tdt.OriginalTransactionID, tdt.Payment, tdt.OrderID, tdt.TaxRate, tdt.Terms, tdt.TillID, tdt.ChannelID, tdt.TransferDetails, tdt.Type, tdt.CreateTime, tdt.BookTime, tdt.ValueTime,
	)
	if err := row.Scan(&id); err != nil {
		return err
	}
	return nil
}

func (repo *Repository) ListTransactionDepositTransactions(ctx context.Context, filter string, pageSize int32, orderBy string, after *db.ListPosition) (db.ListStat, []*db.TransactionDepositTransaction, *db.ListPosition, error) {
	if filter != "" {
		return db.ListStat{}, nil, nil, fmt.Errorf("filter is unimplemented")
	}
	if orderBy == "" {
		orderBy = "id"
	}
	whereClause := `
		(
			(all_entries.ordered_idx > $2) OR
			(all_entries.ordered_idx = $2 AND all_entries.id > $3)
		)
	`
	if after == nil {
		// Use placeholder values but always evaluate to true.
		whereClause = "$2::INTEGER = $3"
		after = &db.ListPosition{
			Data: 0,
			ID:   0,
		}
	}
	const stmt = `WITH all_entries AS (
			SELECT
				quote_ident($1) AS ordered_idx, transaction_deposit_transactions.id,

				transaction_deposit_transactions_card_transaction_tbl.transaction_id,
				transaction_deposit_transactions_card_transaction_tbl.advice,
				transaction_deposit_transactions_card_transaction_tbl.amount,
				transaction_deposit_transactions_card_transaction_tbl.acceptor,
				transaction_deposit_transactions_card_transaction_tbl.card_id,
				transaction_deposit_transactions_card_transaction_tbl.authorization_id,
				transaction_deposit_transactions_card_transaction_tbl.transaction_time,

				transaction_deposit_transactions.transaction_id,
				transaction_deposit_transactions.user_id,
				transaction_deposit_transactions.total_change,
				transaction_deposit_transactions.affected_amounts,
				transaction_deposit_transactions.adjustment_transaction_id,
				transaction_deposit_transactions.block_id,
				transaction_deposit_transactions.branch_id,
				transaction_deposit_transactions.centre_id,
				transaction_deposit_transactions.parent_account_id,
				transaction_deposit_transactions.fees,
				transaction_deposit_transactions.interest_accrued_amounts,
				transaction_deposit_transactions.migration_event_id,
				transaction_deposit_transactions.notes,
				transaction_deposit_transactions.original_transaction_id,
				transaction_deposit_transactions.payment,
				transaction_deposit_transactions.order_id,
				transaction_deposit_transactions.tax_rate,
				transaction_deposit_transactions.terms,
				transaction_deposit_transactions.till_id,
				transaction_deposit_transactions.channel_id,
				transaction_deposit_transactions.transfer_details,
				transaction_deposit_transactions.type,
				transaction_deposit_transactions.create_time,
				transaction_deposit_transactions.book_time,
				transaction_deposit_transactions.value_time
			FROM
				transaction_deposit_transactions
				JOIN card_transactions AS transaction_deposit_transactions_card_transaction_tbl ON transaction_deposit_transactions_card_transaction_tbl.id = transaction_deposit_transactions.card_transaction
			WHERE
				%s
		), all_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				all_entries
		), filtered AS (
			SELECT
				*
			FROM
				all_entries
			WHERE %s
		), filtered_count AS (
			SELECT
				COUNT(*) AS count
			FROM
				filtered
		)
		SELECT
			all_count.count, filtered_count.count,
			NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
		FROM
			all_count
			CROSS JOIN filtered_count
		UNION ALL
		(
			SELECT
				*
			FROM
				all_count
				CROSS JOIN filtered_count
				CROSS JOIN filtered
			ORDER BY
				quote_ident($1), filtered.id
			LIMIT
				$4
		)`

	filterSQL := "TRUE" // TODO
	query := fmt.Sprintf(stmt, filterSQL, whereClause)
	rows, err := repo.db.QueryContext(ctx, query, "transaction_deposit_transactions."+orderBy, after.Data, after.ID, pageSize)
	if err != nil {
		return db.ListStat{}, nil, nil, err
	}

	defer rows.Close()
	result := make([]*db.TransactionDepositTransaction, 0, pageSize)
	var nextPos db.ListPosition
	var listStat db.ListStat
	if !rows.Next() {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	var x any
	if err := rows.Scan(
		&listStat.Total, &listStat.Remaining,
		&x, &x,
		&x, &x, &x, &x, &x, &x, &x,
		&x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x, &x,
	); err != nil {
		return db.ListStat{}, nil, nil, err
	}
	for rows.Next() {
		var next db.TransactionDepositTransaction
		if err := rows.Scan(
			&listStat.Total, &listStat.Remaining,
			&nextPos.Data, &nextPos.ID,
			&next.CardTransaction.TransactionID, &next.CardTransaction.Advice, &next.CardTransaction.Amount, &next.CardTransaction.Acceptor, &next.CardTransaction.CardID, &next.CardTransaction.AuthorizationID, &next.CardTransaction.TransactionTime,
			&next.TransactionID, &next.UserID, &next.TotalChange, &next.AffectedAmounts, &next.AdjustmentTransactionID, &next.BlockID, &next.BranchID, &next.CentreID, &next.ParentAccountID, &next.Fees, &next.InterestAccruedAmounts, &next.MigrationEventID, &next.Notes, &next.OriginalTransactionID, &next.Payment, &next.OrderID, &next.TaxRate, &next.Terms, &next.TillID, &next.ChannelID, &next.TransferDetails, &next.Type, &next.CreateTime, &next.BookTime, &next.ValueTime,
		); err != nil {
			return db.ListStat{}, nil, nil, err
		}
		result = append(result, &next)
	}
	if rows.Err() != nil {
		return db.ListStat{}, nil, nil, rows.Err()
	}
	return listStat, result, &nextPos, nil
}

func (repo *Repository) TransactionDepositTransactionByID(ctx context.Context, id int32) (*db.TransactionDepositTransaction, error) {
	const stmt = `SELECT
		transaction_deposit_transactions.id,

		transaction_deposit_transactions_card_transaction_tbl.transaction_id,
		transaction_deposit_transactions_card_transaction_tbl.advice,
		transaction_deposit_transactions_card_transaction_tbl.amount,
		transaction_deposit_transactions_card_transaction_tbl.acceptor,
		transaction_deposit_transactions_card_transaction_tbl.card_id,
		transaction_deposit_transactions_card_transaction_tbl.authorization_id,
		transaction_deposit_transactions_card_transaction_tbl.transaction_time,

		transaction_deposit_transactions.transaction_id,
		transaction_deposit_transactions.user_id,
		transaction_deposit_transactions.total_change,
		transaction_deposit_transactions.affected_amounts,
		transaction_deposit_transactions.adjustment_transaction_id,
		transaction_deposit_transactions.block_id,
		transaction_deposit_transactions.branch_id,
		transaction_deposit_transactions.centre_id,
		transaction_deposit_transactions.parent_account_id,
		transaction_deposit_transactions.fees,
		transaction_deposit_transactions.interest_accrued_amounts,
		transaction_deposit_transactions.migration_event_id,
		transaction_deposit_transactions.notes,
		transaction_deposit_transactions.original_transaction_id,
		transaction_deposit_transactions.payment,
		transaction_deposit_transactions.order_id,
		transaction_deposit_transactions.tax_rate,
		transaction_deposit_transactions.terms,
		transaction_deposit_transactions.till_id,
		transaction_deposit_transactions.channel_id,
		transaction_deposit_transactions.transfer_details,
		transaction_deposit_transactions.type,
		transaction_deposit_transactions.create_time,
		transaction_deposit_transactions.book_time,
		transaction_deposit_transactions.value_time
	FROM
		transaction_deposit_transactions
		JOIN card_transactions AS transaction_deposit_transactions_card_transaction_tbl ON transaction_deposit_transactions_card_transaction_tbl.id = transaction_deposit_transactions.card_transaction
	WHERE
		id = $1`

	var tdt db.TransactionDepositTransaction
	row := repo.db.QueryRowContext(ctx, stmt, id)
	if err := row.Scan(
		&tdt.ID,
		&tdt.CardTransaction.TransactionID, &tdt.CardTransaction.Advice, &tdt.CardTransaction.Amount, &tdt.CardTransaction.Acceptor, &tdt.CardTransaction.CardID, &tdt.CardTransaction.AuthorizationID, &tdt.CardTransaction.TransactionTime,
		&tdt.TransactionID, &tdt.UserID, &tdt.TotalChange, &tdt.AffectedAmounts, &tdt.AdjustmentTransactionID, &tdt.BlockID, &tdt.BranchID, &tdt.CentreID, &tdt.ParentAccountID, &tdt.Fees, &tdt.InterestAccruedAmounts, &tdt.MigrationEventID, &tdt.Notes, &tdt.OriginalTransactionID, &tdt.Payment, &tdt.OrderID, &tdt.TaxRate, &tdt.Terms, &tdt.TillID, &tdt.ChannelID, &tdt.TransferDetails, &tdt.Type, &tdt.CreateTime, &tdt.BookTime, &tdt.ValueTime,
	); err != nil {
		return nil, err
	}

	return &tdt, nil
}

func (repo *Repository) UpdateTransactionDepositTransactionByID(ctx context.Context, tdt *db.TransactionDepositTransaction) error {
	const stmt = `WITH transaction_deposit_transactions_card_transactions AS (
		UPDATE card_transactions
		SET transaction_id=$1,
			advice=$2,
			amount=$3,
			acceptor=$4,
			card_id=$5,
			authorization_id=$6,
			transaction_time=$7
		FROM transaction_deposit_transactions
		WHERE transaction_deposit_transactions.card_transaction = card_transactions.id AND
			transaction_deposit_transactions.id = $8
	)
	UPDATE transaction_deposit_transactions
	SET transaction_id=$9,
		user_id=$10,
		total_change=$11,
		affected_amounts=$12,
		adjustment_transaction_id=$13,
		block_id=$14,
		branch_id=$15,
		centre_id=$16,
		parent_account_id=$17,
		fees=$18,
		interest_accrued_amounts=$19,
		migration_event_id=$20,
		notes=$21,
		original_transaction_id=$22,
		payment=$23,
		order_id=$24,
		tax_rate=$25,
		terms=$26,
		till_id=$27,
		channel_id=$28,
		transfer_details=$29,
		type=$30,
		book_time=$31,
		value_time=$32
	WHERE id = $33`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		tdt.CardTransaction.TransactionID, tdt.CardTransaction.Advice, tdt.CardTransaction.Amount, tdt.CardTransaction.Acceptor, tdt.CardTransaction.CardID, tdt.CardTransaction.AuthorizationID, tdt.CardTransaction.TransactionTime, tdt.ID,
		tdt.TransactionID, tdt.UserID, tdt.TotalChange, tdt.AffectedAmounts, tdt.AdjustmentTransactionID, tdt.BlockID, tdt.BranchID, tdt.CentreID, tdt.ParentAccountID, tdt.Fees, tdt.InterestAccruedAmounts, tdt.MigrationEventID, tdt.Notes, tdt.OriginalTransactionID, tdt.Payment, tdt.OrderID, tdt.TaxRate, tdt.Terms, tdt.TillID, tdt.ChannelID, tdt.TransferDetails, tdt.Type, tdt.BookTime, tdt.ValueTime, tdt.ID,
	)
	return err
}

func (repo *Repository) DeleteTransactionDepositTransactionByID(ctx context.Context, id int32) error {
	const stmt = `WITH transaction_deposit_transactions_card_transactions AS (
		DELETE FROM card_transactions
		USING transaction_deposit_transactions
		WHERE transaction_deposit_transactions.card_transaction = card_transactions.id AND
			transaction_deposit_transactions.id = $1
	)
	DELETE FROM transaction_deposit_transactions
	WHERE id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		id,
	)
	return err
}

func (repo *Repository) TransactionDepositTransactionByTransactionID(ctx context.Context, transactionID string) (*db.TransactionDepositTransaction, error) {
	const stmt = `SELECT
		transaction_deposit_transactions.id,

		transaction_deposit_transactions_card_transaction_tbl.transaction_id,
		transaction_deposit_transactions_card_transaction_tbl.advice,
		transaction_deposit_transactions_card_transaction_tbl.amount,
		transaction_deposit_transactions_card_transaction_tbl.acceptor,
		transaction_deposit_transactions_card_transaction_tbl.card_id,
		transaction_deposit_transactions_card_transaction_tbl.authorization_id,
		transaction_deposit_transactions_card_transaction_tbl.transaction_time,

		transaction_deposit_transactions.transaction_id,
		transaction_deposit_transactions.user_id,
		transaction_deposit_transactions.total_change,
		transaction_deposit_transactions.affected_amounts,
		transaction_deposit_transactions.adjustment_transaction_id,
		transaction_deposit_transactions.block_id,
		transaction_deposit_transactions.branch_id,
		transaction_deposit_transactions.centre_id,
		transaction_deposit_transactions.parent_account_id,
		transaction_deposit_transactions.fees,
		transaction_deposit_transactions.interest_accrued_amounts,
		transaction_deposit_transactions.migration_event_id,
		transaction_deposit_transactions.notes,
		transaction_deposit_transactions.original_transaction_id,
		transaction_deposit_transactions.payment,
		transaction_deposit_transactions.order_id,
		transaction_deposit_transactions.tax_rate,
		transaction_deposit_transactions.terms,
		transaction_deposit_transactions.till_id,
		transaction_deposit_transactions.channel_id,
		transaction_deposit_transactions.transfer_details,
		transaction_deposit_transactions.type,
		transaction_deposit_transactions.create_time,
		transaction_deposit_transactions.book_time,
		transaction_deposit_transactions.value_time
	FROM
		transaction_deposit_transactions
		JOIN card_transactions AS transaction_deposit_transactions_card_transaction_tbl ON transaction_deposit_transactions_card_transaction_tbl.id = transaction_deposit_transactions.card_transaction
	WHERE
		transaction_id = $1`

	var tdt db.TransactionDepositTransaction
	row := repo.db.QueryRowContext(ctx, stmt, transactionID)
	if err := row.Scan(
		&tdt.ID,
		&tdt.CardTransaction.TransactionID, &tdt.CardTransaction.Advice, &tdt.CardTransaction.Amount, &tdt.CardTransaction.Acceptor, &tdt.CardTransaction.CardID, &tdt.CardTransaction.AuthorizationID, &tdt.CardTransaction.TransactionTime,
		&tdt.TransactionID, &tdt.UserID, &tdt.TotalChange, &tdt.AffectedAmounts, &tdt.AdjustmentTransactionID, &tdt.BlockID, &tdt.BranchID, &tdt.CentreID, &tdt.ParentAccountID, &tdt.Fees, &tdt.InterestAccruedAmounts, &tdt.MigrationEventID, &tdt.Notes, &tdt.OriginalTransactionID, &tdt.Payment, &tdt.OrderID, &tdt.TaxRate, &tdt.Terms, &tdt.TillID, &tdt.ChannelID, &tdt.TransferDetails, &tdt.Type, &tdt.CreateTime, &tdt.BookTime, &tdt.ValueTime,
	); err != nil {
		return nil, err
	}

	return &tdt, nil
}

func (repo *Repository) UpdateTransactionDepositTransactionByTransactionID(ctx context.Context, tdt *db.TransactionDepositTransaction) error {
	const stmt = `WITH transaction_deposit_transactions_card_transactions AS (
		UPDATE card_transactions
		SET transaction_id=$1,
			advice=$2,
			amount=$3,
			acceptor=$4,
			card_id=$5,
			authorization_id=$6,
			transaction_time=$7
		FROM transaction_deposit_transactions
		WHERE transaction_deposit_transactions.card_transaction = card_transactions.id AND
			transaction_deposit_transactions.transaction_id = $8
	)
	UPDATE transaction_deposit_transactions
	SET transaction_id=$9,
		user_id=$10,
		total_change=$11,
		affected_amounts=$12,
		adjustment_transaction_id=$13,
		block_id=$14,
		branch_id=$15,
		centre_id=$16,
		parent_account_id=$17,
		fees=$18,
		interest_accrued_amounts=$19,
		migration_event_id=$20,
		notes=$21,
		original_transaction_id=$22,
		payment=$23,
		order_id=$24,
		tax_rate=$25,
		terms=$26,
		till_id=$27,
		channel_id=$28,
		transfer_details=$29,
		type=$30,
		book_time=$31,
		value_time=$32
	WHERE transaction_id = $33`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		tdt.CardTransaction.TransactionID, tdt.CardTransaction.Advice, tdt.CardTransaction.Amount, tdt.CardTransaction.Acceptor, tdt.CardTransaction.CardID, tdt.CardTransaction.AuthorizationID, tdt.CardTransaction.TransactionTime, tdt.TransactionID,
		tdt.TransactionID, tdt.UserID, tdt.TotalChange, tdt.AffectedAmounts, tdt.AdjustmentTransactionID, tdt.BlockID, tdt.BranchID, tdt.CentreID, tdt.ParentAccountID, tdt.Fees, tdt.InterestAccruedAmounts, tdt.MigrationEventID, tdt.Notes, tdt.OriginalTransactionID, tdt.Payment, tdt.OrderID, tdt.TaxRate, tdt.Terms, tdt.TillID, tdt.ChannelID, tdt.TransferDetails, tdt.Type, tdt.BookTime, tdt.ValueTime, tdt.TransactionID,
	)
	return err
}

func (repo *Repository) DeleteTransactionDepositTransactionByTransactionID(ctx context.Context, transactionID string) error {
	const stmt = `WITH transaction_deposit_transactions_card_transactions AS (
		DELETE FROM card_transactions
		USING transaction_deposit_transactions
		WHERE transaction_deposit_transactions.card_transaction = card_transactions.id AND
			transaction_deposit_transactions.transaction_id = $1
	)
	DELETE FROM transaction_deposit_transactions
	WHERE transaction_id = $1`
	_, err := repo.db.ExecContext(
		ctx, stmt,
		transactionID,
	)
	return err
}
