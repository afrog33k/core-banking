package main

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

// signature is the string prepended to the template by gen.go.
// It is used to determine if the file was generated and should be kept in sync
// with tools/services/gen/gen.go.
const signature = `// Code generated by gen.go. DO NOT EDIT.
// To avoid your changes from being overwritten, delete this header.

`

func main() {
	dryRun := flag.Bool("dry-run", false, "list all files that will be removed")
	flag.Parse()
	if len(flag.Args()) == 0 {
		fmt.Printf("Usage: %s [-dry-run] <target folder>\n", os.Args[0])
		return
	}
	target := flag.Args()[0]
	deleted := make([]string, 0)
	err := filepath.Walk(target, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		toRemove, err := shouldRemove(path)
		if err != nil {
			return err
		}
		if !toRemove {
			return nil
		}
		deleted = append(deleted, path)
		if *dryRun {
			return nil
		}
		if err := os.Remove(path); err != nil {
			return fmt.Errorf("error deleting %q: %w", path, err)
		}
		return nil
	})
	if len(deleted) > 0 {
		if *dryRun {
			fmt.Println("Will delete:")
			fmt.Println(strings.Join(deleted, " "))
		} else {
			fmt.Printf("+ rm %s\n", strings.Join(deleted, " "))
		}
	}
	if err != nil {
		fmt.Println("error walking:", err)
		os.Exit(1)
	}
}

func shouldRemove(path string) (bool, error) {
	f, err := os.Open(path)
	if err != nil {
		return false, fmt.Errorf("error opening %q: %w", path, err)
	}
	defer f.Close()
	buffer := make([]byte, len(signature))
	_, err = io.ReadFull(f, buffer)
	if errors.Is(err, io.ErrUnexpectedEOF) {
		// Skip file. It's shorter than the signature.
		return false, nil
	}
	if err != nil {
		return false, err
	}
	return string(buffer) == signature, nil
}
